diff --git a/dune-project b/dune-project
index 1a9acf5..88fd4c9 100644
--- a/dune-project
+++ b/dune-project
@@ -19,19 +19,6 @@
    ocamlformat
  ))
 
-(package
- (name ez_hash)
- (synopsis "Hash functions: sha3, sha256, blake2b")
- (description "\nHash functions: sha3, sha256, blake2b\n")
- (depends
-   (ocaml (>= 4.08.0))
-   blake2
-   ppx_inline_test
-   ppx_expect
-   odoc
-   ocamlformat
- ))
-
 (package
  (name solidity-common)
  (synopsis "The ocaml-solidity project")
diff --git a/ez_hash.opam b/ez_hash.opam
deleted file mode 100644
index 1483eb3..0000000
--- a/ez_hash.opam
+++ /dev/null
@@ -1,49 +0,0 @@
-# This file was generated by `drom` from `drom.toml`.
-# Do not modify, or add to the `skip` field of `drom.toml`.
-opam-version: "2.0"
-name: "ez_hash"
-version: "0.2.0"
-license: "LGPL-2.1-only with OCaml-LGPL-linking-exception"
-synopsis: "Hash functions: sha3, sha256, blake2b"
-description: """
-
-Hash functions: sha3, sha256, blake2b
-"""
-authors: ["Fabrice Le Fessant <fabrice.le_fessant@ocamlpro.com>"]
-maintainer: [
-  "David Declerck <david.declerck@ocamlpro.com>"
-  "Steven De Oliveira <steven.de-oliveira@ocamlpro.com>"
-]
-homepage: "https://github.com/OcamlPro/ocaml-solidity"
-doc: "https://OCamlPro.github.io/ocaml-solidity/sphinx"
-bug-reports: "https://github.com/OCamlPro/ocaml-solidity/issues"
-dev-repo: "git+https://github.com/OcamlPro/ocaml-solidity.git"
-tags: "org:OCamlPro"
-build: [
-  ["dune" "subst"] {dev}
-  ["sh" "-c" "./scripts/before.sh build '%{name}%'"]
-  [
-    "dune"
-    "build"
-    "-p"
-    name
-    "-j"
-    jobs
-    "@install"
-    "@runtest" {with-test}
-    "@doc" {with-doc}
-  ]
-  ["sh" "-c" "./scripts/after.sh build '%{name}%'"]
-]
-install: [
-  ["sh" "-c" "./scripts/before.sh install '%{name}%'"]
-]
-depends: [
-  "ocaml" {>= "4.08.0"}
-  "dune" {>= "2.6.0"}
-  "blake2" {}
-  "ppx_inline_test" {with-test}
-  "ppx_expect" {with-test}
-  "odoc" {with-doc}
-  "ocamlformat" {with-test}
-]
\ No newline at end of file
diff --git a/src/ez_hash/README.txt b/src/ez_hash/README.txt
deleted file mode 100644
index fd429b3..0000000
--- a/src/ez_hash/README.txt
+++ /dev/null
@@ -1,13 +0,0 @@
-ez-hash
-=======
-
-A library of hash functions, based on C implementations.
-
-Currently contains:
-* Blake2b
-* Sha256
-* Sha3
-
-In Dune, the Blake implementation is not built, because it conflicts
-with the one of the "blake2" OCaml package.
-
diff --git a/src/ez_hash/blake2-impl.h b/src/ez_hash/blake2-impl.h
deleted file mode 100644
index 5dff7fc..0000000
--- a/src/ez_hash/blake2-impl.h
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
-   BLAKE2 reference source code package - reference C implementations
-
-   Copyright 2012, Samuel Neves <sneves@dei.uc.pt>.  You may use this under the
-   terms of the CC0, the OpenSSL Licence, or the Apache Public License 2.0, at
-   your option.  The terms of these licenses can be found at:
-
-   - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
-   - OpenSSL license   : https://www.openssl.org/source/license.html
-   - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0
-
-   More information about the BLAKE2 hash function can be found at
-   https://blake2.net.
-*/
-#ifndef BLAKE2_IMPL_H
-#define BLAKE2_IMPL_H
-
-#include <stdint.h>
-#include <string.h>
-
-#if !defined(__cplusplus) && (!defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901L)
-  #if   defined(_MSC_VER)
-    #define BLAKE2_INLINE __inline
-  #elif defined(__GNUC__)
-    #define BLAKE2_INLINE __inline__
-  #else
-    #define BLAKE2_INLINE
-  #endif
-#else
-  #define BLAKE2_INLINE inline
-#endif
-
-static BLAKE2_INLINE uint32_t load32( const void *src )
-{
-#if defined(NATIVE_LITTLE_ENDIAN)
-  uint32_t w;
-  memcpy(&w, src, sizeof w);
-  return w;
-#else
-  const uint8_t *p = ( const uint8_t * )src;
-  return (( uint32_t )( p[0] ) <<  0) |
-         (( uint32_t )( p[1] ) <<  8) |
-         (( uint32_t )( p[2] ) << 16) |
-         (( uint32_t )( p[3] ) << 24) ;
-#endif
-}
-
-static BLAKE2_INLINE uint64_t load64( const void *src )
-{
-#if defined(NATIVE_LITTLE_ENDIAN)
-  uint64_t w;
-  memcpy(&w, src, sizeof w);
-  return w;
-#else
-  const uint8_t *p = ( const uint8_t * )src;
-  return (( uint64_t )( p[0] ) <<  0) |
-         (( uint64_t )( p[1] ) <<  8) |
-         (( uint64_t )( p[2] ) << 16) |
-         (( uint64_t )( p[3] ) << 24) |
-         (( uint64_t )( p[4] ) << 32) |
-         (( uint64_t )( p[5] ) << 40) |
-         (( uint64_t )( p[6] ) << 48) |
-         (( uint64_t )( p[7] ) << 56) ;
-#endif
-}
-
-static BLAKE2_INLINE uint16_t load16( const void *src )
-{
-#if defined(NATIVE_LITTLE_ENDIAN)
-  uint16_t w;
-  memcpy(&w, src, sizeof w);
-  return w;
-#else
-  const uint8_t *p = ( const uint8_t * )src;
-  return (( uint16_t )( p[0] ) <<  0) |
-         (( uint16_t )( p[1] ) <<  8) ;
-#endif
-}
-
-static BLAKE2_INLINE void store16( void *dst, uint16_t w )
-{
-#if defined(NATIVE_LITTLE_ENDIAN)
-  memcpy(dst, &w, sizeof w);
-#else
-  uint8_t *p = ( uint8_t * )dst;
-  *p++ = ( uint8_t )w; w >>= 8;
-  *p++ = ( uint8_t )w;
-#endif
-}
-
-static BLAKE2_INLINE void store32( void *dst, uint32_t w )
-{
-#if defined(NATIVE_LITTLE_ENDIAN)
-  memcpy(dst, &w, sizeof w);
-#else
-  uint8_t *p = ( uint8_t * )dst;
-  p[0] = (uint8_t)(w >>  0);
-  p[1] = (uint8_t)(w >>  8);
-  p[2] = (uint8_t)(w >> 16);
-  p[3] = (uint8_t)(w >> 24);
-#endif
-}
-
-static BLAKE2_INLINE void store64( void *dst, uint64_t w )
-{
-#if defined(NATIVE_LITTLE_ENDIAN)
-  memcpy(dst, &w, sizeof w);
-#else
-  uint8_t *p = ( uint8_t * )dst;
-  p[0] = (uint8_t)(w >>  0);
-  p[1] = (uint8_t)(w >>  8);
-  p[2] = (uint8_t)(w >> 16);
-  p[3] = (uint8_t)(w >> 24);
-  p[4] = (uint8_t)(w >> 32);
-  p[5] = (uint8_t)(w >> 40);
-  p[6] = (uint8_t)(w >> 48);
-  p[7] = (uint8_t)(w >> 56);
-#endif
-}
-
-static BLAKE2_INLINE uint64_t load48( const void *src )
-{
-  const uint8_t *p = ( const uint8_t * )src;
-  return (( uint64_t )( p[0] ) <<  0) |
-         (( uint64_t )( p[1] ) <<  8) |
-         (( uint64_t )( p[2] ) << 16) |
-         (( uint64_t )( p[3] ) << 24) |
-         (( uint64_t )( p[4] ) << 32) |
-         (( uint64_t )( p[5] ) << 40) ;
-}
-
-static BLAKE2_INLINE void store48( void *dst, uint64_t w )
-{
-  uint8_t *p = ( uint8_t * )dst;
-  p[0] = (uint8_t)(w >>  0);
-  p[1] = (uint8_t)(w >>  8);
-  p[2] = (uint8_t)(w >> 16);
-  p[3] = (uint8_t)(w >> 24);
-  p[4] = (uint8_t)(w >> 32);
-  p[5] = (uint8_t)(w >> 40);
-}
-
-static BLAKE2_INLINE uint32_t rotr32( const uint32_t w, const unsigned c )
-{
-  return ( w >> c ) | ( w << ( 32 - c ) );
-}
-
-static BLAKE2_INLINE uint64_t rotr64( const uint64_t w, const unsigned c )
-{
-  return ( w >> c ) | ( w << ( 64 - c ) );
-}
-
-/* prevents compiler optimizing out memset() */
-static BLAKE2_INLINE void secure_zero_memory(void *v, size_t n)
-{
-  static void *(*const volatile memset_v)(void *, int, size_t) = &memset;
-  memset_v(v, 0, n);
-}
-
-#endif
diff --git a/src/ez_hash/blake2.h b/src/ez_hash/blake2.h
deleted file mode 100644
index ad62f26..0000000
--- a/src/ez_hash/blake2.h
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
-   BLAKE2 reference source code package - reference C implementations
-
-   Copyright 2012, Samuel Neves <sneves@dei.uc.pt>.  You may use this under the
-   terms of the CC0, the OpenSSL Licence, or the Apache Public License 2.0, at
-   your option.  The terms of these licenses can be found at:
-
-   - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
-   - OpenSSL license   : https://www.openssl.org/source/license.html
-   - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0
-
-   More information about the BLAKE2 hash function can be found at
-   https://blake2.net.
-*/
-#ifndef BLAKE2_H
-#define BLAKE2_H
-
-#include <stddef.h>
-#include <stdint.h>
-
-#if defined(_MSC_VER)
-#define BLAKE2_PACKED(x) __pragma(pack(push, 1)) x __pragma(pack(pop))
-#else
-#define BLAKE2_PACKED(x) x __attribute__((packed))
-#endif
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-
-  enum blake2s_constant
-  {
-    BLAKE2S_BLOCKBYTES = 64,
-    BLAKE2S_OUTBYTES   = 32,
-    BLAKE2S_KEYBYTES   = 32,
-    BLAKE2S_SALTBYTES  = 8,
-    BLAKE2S_PERSONALBYTES = 8
-  };
-
-  enum blake2b_constant
-  {
-    BLAKE2B_BLOCKBYTES = 128,
-    BLAKE2B_OUTBYTES   = 64,
-    BLAKE2B_KEYBYTES   = 64,
-    BLAKE2B_SALTBYTES  = 16,
-    BLAKE2B_PERSONALBYTES = 16
-  };
-
-  typedef struct blake2s_state__
-  {
-    uint32_t h[8];
-    uint32_t t[2];
-    uint32_t f[2];
-    uint8_t  buf[BLAKE2S_BLOCKBYTES];
-    size_t   buflen;
-    size_t   outlen;
-    uint8_t  last_node;
-  } blake2s_state;
-
-  typedef struct blake2b_state__
-  {
-    uint64_t h[8];
-    uint64_t t[2];
-    uint64_t f[2];
-    uint8_t  buf[BLAKE2B_BLOCKBYTES];
-    size_t   buflen;
-    size_t   outlen;
-    uint8_t  last_node;
-  } blake2b_state;
-
-  typedef struct blake2sp_state__
-  {
-    blake2s_state S[8][1];
-    blake2s_state R[1];
-    uint8_t       buf[8 * BLAKE2S_BLOCKBYTES];
-    size_t        buflen;
-    size_t        outlen;
-  } blake2sp_state;
-
-  typedef struct blake2bp_state__
-  {
-    blake2b_state S[4][1];
-    blake2b_state R[1];
-    uint8_t       buf[4 * BLAKE2B_BLOCKBYTES];
-    size_t        buflen;
-    size_t        outlen;
-  } blake2bp_state;
-
-
-  BLAKE2_PACKED(struct blake2s_param__
-  {
-    uint8_t  digest_length; /* 1 */
-    uint8_t  key_length;    /* 2 */
-    uint8_t  fanout;        /* 3 */
-    uint8_t  depth;         /* 4 */
-    uint32_t leaf_length;   /* 8 */
-    uint32_t node_offset;  /* 12 */
-    uint16_t xof_length;    /* 14 */
-    uint8_t  node_depth;    /* 15 */
-    uint8_t  inner_length;  /* 16 */
-    /* uint8_t  reserved[0]; */
-    uint8_t  salt[BLAKE2S_SALTBYTES]; /* 24 */
-    uint8_t  personal[BLAKE2S_PERSONALBYTES];  /* 32 */
-  });
-
-  typedef struct blake2s_param__ blake2s_param;
-
-  BLAKE2_PACKED(struct blake2b_param__
-  {
-    uint8_t  digest_length; /* 1 */
-    uint8_t  key_length;    /* 2 */
-    uint8_t  fanout;        /* 3 */
-    uint8_t  depth;         /* 4 */
-    uint32_t leaf_length;   /* 8 */
-    uint32_t node_offset;   /* 12 */
-    uint32_t xof_length;    /* 16 */
-    uint8_t  node_depth;    /* 17 */
-    uint8_t  inner_length;  /* 18 */
-    uint8_t  reserved[14];  /* 32 */
-    uint8_t  salt[BLAKE2B_SALTBYTES]; /* 48 */
-    uint8_t  personal[BLAKE2B_PERSONALBYTES];  /* 64 */
-  });
-
-  typedef struct blake2b_param__ blake2b_param;
-
-  typedef struct blake2xs_state__
-  {
-    blake2s_state S[1];
-    blake2s_param P[1];
-  } blake2xs_state;
-
-  typedef struct blake2xb_state__
-  {
-    blake2b_state S[1];
-    blake2b_param P[1];
-  } blake2xb_state;
-
-  /* Padded structs result in a compile-time error */
-  enum {
-    BLAKE2_DUMMY_1 = 1/(sizeof(blake2s_param) == BLAKE2S_OUTBYTES),
-    BLAKE2_DUMMY_2 = 1/(sizeof(blake2b_param) == BLAKE2B_OUTBYTES)
-  };
-
-  /* Streaming API */
-  int blake2s_init( blake2s_state *S, size_t outlen );
-  int blake2s_init_key( blake2s_state *S, size_t outlen, const void *key, size_t keylen );
-  int blake2s_init_param( blake2s_state *S, const blake2s_param *P );
-  int blake2s_update( blake2s_state *S, const void *in, size_t inlen );
-  int blake2s_final( blake2s_state *S, void *out, size_t outlen );
-
-  int blake2b_init( blake2b_state *S, size_t outlen );
-  int blake2b_init_key( blake2b_state *S, size_t outlen, const void *key, size_t keylen );
-  int blake2b_init_param( blake2b_state *S, const blake2b_param *P );
-  int blake2b_update( blake2b_state *S, const void *in, size_t inlen );
-  int blake2b_final( blake2b_state *S, void *out, size_t outlen );
-
-  int blake2sp_init( blake2sp_state *S, size_t outlen );
-  int blake2sp_init_key( blake2sp_state *S, size_t outlen, const void *key, size_t keylen );
-  int blake2sp_update( blake2sp_state *S, const void *in, size_t inlen );
-  int blake2sp_final( blake2sp_state *S, void *out, size_t outlen );
-
-  int blake2bp_init( blake2bp_state *S, size_t outlen );
-  int blake2bp_init_key( blake2bp_state *S, size_t outlen, const void *key, size_t keylen );
-  int blake2bp_update( blake2bp_state *S, const void *in, size_t inlen );
-  int blake2bp_final( blake2bp_state *S, void *out, size_t outlen );
-
-  /* Variable output length API */
-  int blake2xs_init( blake2xs_state *S, const size_t outlen );
-  int blake2xs_init_key( blake2xs_state *S, const size_t outlen, const void *key, size_t keylen );
-  int blake2xs_update( blake2xs_state *S, const void *in, size_t inlen );
-  int blake2xs_final(blake2xs_state *S, void *out, size_t outlen);
-
-  int blake2xb_init( blake2xb_state *S, const size_t outlen );
-  int blake2xb_init_key( blake2xb_state *S, const size_t outlen, const void *key, size_t keylen );
-  int blake2xb_update( blake2xb_state *S, const void *in, size_t inlen );
-  int blake2xb_final(blake2xb_state *S, void *out, size_t outlen);
-
-  /* Simple API */
-  int blake2s( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen );
-  int blake2b( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen );
-
-  int blake2sp( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen );
-  int blake2bp( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen );
-
-  int blake2xs( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen );
-  int blake2xb( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen );
-
-  /* This is simply an alias for blake2b */
-  int blake2( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen );
-
-#if defined(__cplusplus)
-}
-#endif
-
-#endif
diff --git a/src/ez_hash/blake2b-ref.c b/src/ez_hash/blake2b-ref.c
deleted file mode 100644
index cd38b1b..0000000
--- a/src/ez_hash/blake2b-ref.c
+++ /dev/null
@@ -1,379 +0,0 @@
-/*
-   BLAKE2 reference source code package - reference C implementations
-
-   Copyright 2012, Samuel Neves <sneves@dei.uc.pt>.  You may use this under the
-   terms of the CC0, the OpenSSL Licence, or the Apache Public License 2.0, at
-   your option.  The terms of these licenses can be found at:
-
-   - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
-   - OpenSSL license   : https://www.openssl.org/source/license.html
-   - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0
-
-   More information about the BLAKE2 hash function can be found at
-   https://blake2.net.
-*/
-
-#include <stdint.h>
-#include <string.h>
-#include <stdio.h>
-
-#include "blake2.h"
-#include "blake2-impl.h"
-
-static const uint64_t blake2b_IV[8] =
-{
-  0x6a09e667f3bcc908ULL, 0xbb67ae8584caa73bULL,
-  0x3c6ef372fe94f82bULL, 0xa54ff53a5f1d36f1ULL,
-  0x510e527fade682d1ULL, 0x9b05688c2b3e6c1fULL,
-  0x1f83d9abfb41bd6bULL, 0x5be0cd19137e2179ULL
-};
-
-static const uint8_t blake2b_sigma[12][16] =
-{
-  {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,
-  { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 } ,
-  { 11,  8, 12,  0,  5,  2, 15, 13, 10, 14,  3,  6,  7,  1,  9,  4 } ,
-  {  7,  9,  3,  1, 13, 12, 11, 14,  2,  6,  5, 10,  4,  0, 15,  8 } ,
-  {  9,  0,  5,  7,  2,  4, 10, 15, 14,  1, 11, 12,  6,  8,  3, 13 } ,
-  {  2, 12,  6, 10,  0, 11,  8,  3,  4, 13,  7,  5, 15, 14,  1,  9 } ,
-  { 12,  5,  1, 15, 14, 13,  4, 10,  0,  7,  6,  3,  9,  2,  8, 11 } ,
-  { 13, 11,  7, 14, 12,  1,  3,  9,  5,  0, 15,  4,  8,  6,  2, 10 } ,
-  {  6, 15, 14,  9, 11,  3,  0,  8, 12,  2, 13,  7,  1,  4, 10,  5 } ,
-  { 10,  2,  8,  4,  7,  6,  1,  5, 15, 11,  9, 14,  3, 12, 13 , 0 } ,
-  {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,
-  { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 }
-};
-
-
-static void blake2b_set_lastnode( blake2b_state *S )
-{
-  S->f[1] = (uint64_t)-1;
-}
-
-/* Some helper functions, not necessarily useful */
-static int blake2b_is_lastblock( const blake2b_state *S )
-{
-  return S->f[0] != 0;
-}
-
-static void blake2b_set_lastblock( blake2b_state *S )
-{
-  if( S->last_node ) blake2b_set_lastnode( S );
-
-  S->f[0] = (uint64_t)-1;
-}
-
-static void blake2b_increment_counter( blake2b_state *S, const uint64_t inc )
-{
-  S->t[0] += inc;
-  S->t[1] += ( S->t[0] < inc );
-}
-
-static void blake2b_init0( blake2b_state *S )
-{
-  size_t i;
-  memset( S, 0, sizeof( blake2b_state ) );
-
-  for( i = 0; i < 8; ++i ) S->h[i] = blake2b_IV[i];
-}
-
-/* init xors IV with input parameter block */
-int blake2b_init_param( blake2b_state *S, const blake2b_param *P )
-{
-  const uint8_t *p = ( const uint8_t * )( P );
-  size_t i;
-
-  blake2b_init0( S );
-
-  /* IV XOR ParamBlock */
-  for( i = 0; i < 8; ++i )
-    S->h[i] ^= load64( p + sizeof( S->h[i] ) * i );
-
-  S->outlen = P->digest_length;
-  return 0;
-}
-
-
-
-int blake2b_init( blake2b_state *S, size_t outlen )
-{
-  blake2b_param P[1];
-
-  if ( ( !outlen ) || ( outlen > BLAKE2B_OUTBYTES ) ) return -1;
-
-  P->digest_length = (uint8_t)outlen;
-  P->key_length    = 0;
-  P->fanout        = 1;
-  P->depth         = 1;
-  store32( &P->leaf_length, 0 );
-  store32( &P->node_offset, 0 );
-  store32( &P->xof_length, 0 );
-  P->node_depth    = 0;
-  P->inner_length  = 0;
-  memset( P->reserved, 0, sizeof( P->reserved ) );
-  memset( P->salt,     0, sizeof( P->salt ) );
-  memset( P->personal, 0, sizeof( P->personal ) );
-  return blake2b_init_param( S, P );
-}
-
-
-int blake2b_init_key( blake2b_state *S, size_t outlen, const void *key, size_t keylen )
-{
-  blake2b_param P[1];
-
-  if ( ( !outlen ) || ( outlen > BLAKE2B_OUTBYTES ) ) return -1;
-
-  if ( !key || !keylen || keylen > BLAKE2B_KEYBYTES ) return -1;
-
-  P->digest_length = (uint8_t)outlen;
-  P->key_length    = (uint8_t)keylen;
-  P->fanout        = 1;
-  P->depth         = 1;
-  store32( &P->leaf_length, 0 );
-  store32( &P->node_offset, 0 );
-  store32( &P->xof_length, 0 );
-  P->node_depth    = 0;
-  P->inner_length  = 0;
-  memset( P->reserved, 0, sizeof( P->reserved ) );
-  memset( P->salt,     0, sizeof( P->salt ) );
-  memset( P->personal, 0, sizeof( P->personal ) );
-
-  if( blake2b_init_param( S, P ) < 0 ) return -1;
-
-  {
-    uint8_t block[BLAKE2B_BLOCKBYTES];
-    memset( block, 0, BLAKE2B_BLOCKBYTES );
-    memcpy( block, key, keylen );
-    blake2b_update( S, block, BLAKE2B_BLOCKBYTES );
-    secure_zero_memory( block, BLAKE2B_BLOCKBYTES ); /* Burn the key from stack */
-  }
-  return 0;
-}
-
-#define G(r,i,a,b,c,d)                      \
-  do {                                      \
-    a = a + b + m[blake2b_sigma[r][2*i+0]]; \
-    d = rotr64(d ^ a, 32);                  \
-    c = c + d;                              \
-    b = rotr64(b ^ c, 24);                  \
-    a = a + b + m[blake2b_sigma[r][2*i+1]]; \
-    d = rotr64(d ^ a, 16);                  \
-    c = c + d;                              \
-    b = rotr64(b ^ c, 63);                  \
-  } while(0)
-
-#define ROUND(r)                    \
-  do {                              \
-    G(r,0,v[ 0],v[ 4],v[ 8],v[12]); \
-    G(r,1,v[ 1],v[ 5],v[ 9],v[13]); \
-    G(r,2,v[ 2],v[ 6],v[10],v[14]); \
-    G(r,3,v[ 3],v[ 7],v[11],v[15]); \
-    G(r,4,v[ 0],v[ 5],v[10],v[15]); \
-    G(r,5,v[ 1],v[ 6],v[11],v[12]); \
-    G(r,6,v[ 2],v[ 7],v[ 8],v[13]); \
-    G(r,7,v[ 3],v[ 4],v[ 9],v[14]); \
-  } while(0)
-
-static void blake2b_compress( blake2b_state *S, const uint8_t block[BLAKE2B_BLOCKBYTES] )
-{
-  uint64_t m[16];
-  uint64_t v[16];
-  size_t i;
-
-  for( i = 0; i < 16; ++i ) {
-    m[i] = load64( block + i * sizeof( m[i] ) );
-  }
-
-  for( i = 0; i < 8; ++i ) {
-    v[i] = S->h[i];
-  }
-
-  v[ 8] = blake2b_IV[0];
-  v[ 9] = blake2b_IV[1];
-  v[10] = blake2b_IV[2];
-  v[11] = blake2b_IV[3];
-  v[12] = blake2b_IV[4] ^ S->t[0];
-  v[13] = blake2b_IV[5] ^ S->t[1];
-  v[14] = blake2b_IV[6] ^ S->f[0];
-  v[15] = blake2b_IV[7] ^ S->f[1];
-
-  ROUND( 0 );
-  ROUND( 1 );
-  ROUND( 2 );
-  ROUND( 3 );
-  ROUND( 4 );
-  ROUND( 5 );
-  ROUND( 6 );
-  ROUND( 7 );
-  ROUND( 8 );
-  ROUND( 9 );
-  ROUND( 10 );
-  ROUND( 11 );
-
-  for( i = 0; i < 8; ++i ) {
-    S->h[i] = S->h[i] ^ v[i] ^ v[i + 8];
-  }
-}
-
-#undef G
-#undef ROUND
-
-int blake2b_update( blake2b_state *S, const void *pin, size_t inlen )
-{
-  const unsigned char * in = (const unsigned char *)pin;
-  if( inlen > 0 )
-  {
-    size_t left = S->buflen;
-    size_t fill = BLAKE2B_BLOCKBYTES - left;
-    if( inlen > fill )
-    {
-      S->buflen = 0;
-      memcpy( S->buf + left, in, fill ); /* Fill buffer */
-      blake2b_increment_counter( S, BLAKE2B_BLOCKBYTES );
-      blake2b_compress( S, S->buf ); /* Compress */
-      in += fill; inlen -= fill;
-      while(inlen > BLAKE2B_BLOCKBYTES) {
-        blake2b_increment_counter(S, BLAKE2B_BLOCKBYTES);
-        blake2b_compress( S, in );
-        in += BLAKE2B_BLOCKBYTES;
-        inlen -= BLAKE2B_BLOCKBYTES;
-      }
-    }
-    memcpy( S->buf + S->buflen, in, inlen );
-    S->buflen += inlen;
-  }
-  return 0;
-}
-
-int blake2b_final( blake2b_state *S, void *out, size_t outlen )
-{
-  uint8_t buffer[BLAKE2B_OUTBYTES] = {0};
-  size_t i;
-
-  if( out == NULL || outlen < S->outlen )
-    return -1;
-
-  if( blake2b_is_lastblock( S ) )
-    return -1;
-
-  blake2b_increment_counter( S, S->buflen );
-  blake2b_set_lastblock( S );
-  memset( S->buf + S->buflen, 0, BLAKE2B_BLOCKBYTES - S->buflen ); /* Padding */
-  blake2b_compress( S, S->buf );
-
-  for( i = 0; i < 8; ++i ) /* Output full hash to temp buffer */
-    store64( buffer + sizeof( S->h[i] ) * i, S->h[i] );
-
-  memcpy( out, buffer, S->outlen );
-  secure_zero_memory(buffer, sizeof(buffer));
-  return 0;
-}
-
-/* inlen, at least, should be uint64_t. Others can be size_t. */
-int blake2b( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen )
-{
-  blake2b_state S[1];
-
-  /* Verify parameters */
-  if ( NULL == in && inlen > 0 ) return -1;
-
-  if ( NULL == out ) return -1;
-
-  if( NULL == key && keylen > 0 ) return -1;
-
-  if( !outlen || outlen > BLAKE2B_OUTBYTES ) return -1;
-
-  if( keylen > BLAKE2B_KEYBYTES ) return -1;
-
-  if( keylen > 0 )
-  {
-    if( blake2b_init_key( S, outlen, key, keylen ) < 0 ) return -1;
-  }
-  else
-  {
-    if( blake2b_init( S, outlen ) < 0 ) return -1;
-  }
-
-  blake2b_update( S, ( const uint8_t * )in, inlen );
-  blake2b_final( S, out, outlen );
-  return 0;
-}
-
-int blake2( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen ) {
-  return blake2b(out, outlen, in, inlen, key, keylen);
-}
-
-#if defined(SUPERCOP)
-int crypto_hash( unsigned char *out, unsigned char *in, unsigned long long inlen )
-{
-  return blake2b( out, BLAKE2B_OUTBYTES, in, inlen, NULL, 0 );
-}
-#endif
-
-#if defined(BLAKE2B_SELFTEST)
-#include <string.h>
-#include "blake2-kat.h"
-int main( void )
-{
-  uint8_t key[BLAKE2B_KEYBYTES];
-  uint8_t buf[BLAKE2_KAT_LENGTH];
-  size_t i, step;
-
-  for( i = 0; i < BLAKE2B_KEYBYTES; ++i )
-    key[i] = ( uint8_t )i;
-
-  for( i = 0; i < BLAKE2_KAT_LENGTH; ++i )
-    buf[i] = ( uint8_t )i;
-
-  /* Test simple API */
-  for( i = 0; i < BLAKE2_KAT_LENGTH; ++i )
-  {
-    uint8_t hash[BLAKE2B_OUTBYTES];
-    blake2b( hash, BLAKE2B_OUTBYTES, buf, i, key, BLAKE2B_KEYBYTES );
-
-    if( 0 != memcmp( hash, blake2b_keyed_kat[i], BLAKE2B_OUTBYTES ) )
-    {
-      goto fail;
-    }
-  }
-
-  /* Test streaming API */
-  for(step = 1; step < BLAKE2B_BLOCKBYTES; ++step) {
-    for (i = 0; i < BLAKE2_KAT_LENGTH; ++i) {
-      uint8_t hash[BLAKE2B_OUTBYTES];
-      blake2b_state S;
-      uint8_t * p = buf;
-      size_t mlen = i;
-      int err = 0;
-
-      if( (err = blake2b_init_key(&S, BLAKE2B_OUTBYTES, key, BLAKE2B_KEYBYTES)) < 0 ) {
-        goto fail;
-      }
-
-      while (mlen >= step) {
-        if ( (err = blake2b_update(&S, p, step)) < 0 ) {
-          goto fail;
-        }
-        mlen -= step;
-        p += step;
-      }
-      if ( (err = blake2b_update(&S, p, mlen)) < 0) {
-        goto fail;
-      }
-      if ( (err = blake2b_final(&S, hash, BLAKE2B_OUTBYTES)) < 0) {
-        goto fail;
-      }
-
-      if (0 != memcmp(hash, blake2b_keyed_kat[i], BLAKE2B_OUTBYTES)) {
-        goto fail;
-      }
-    }
-  }
-
-  puts( "ok" );
-  return 0;
-fail:
-  puts("error");
-  return -1;
-}
-#endif
diff --git a/src/ez_hash/blake2b-stubs.c b/src/ez_hash/blake2b-stubs.c
deleted file mode 100644
index 82af07d..0000000
--- a/src/ez_hash/blake2b-stubs.c
+++ /dev/null
@@ -1,72 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/*    Copyright (c) 2017       .                                          */
-/*    Fabrice Le Fessant, INRIA & OCamlPro SAS <fabrice@lefessant.net>    */
-/*                                                                        */
-/*    All rights reserved. No warranty, explicit or implicit, provided.   */
-/*                                                                        */
-/**************************************************************************/
-
-#include <caml/mlvalues.h>
-#include <caml/alloc.h>
-
-#include "blake2.h"
-
-value blake2b_ml(value out_s, value in_s, value key_s)
-{
-  void* out = (void *)String_val(out_s);
-  void* in = (void *)String_val(in_s);
-  void* key = (void *)String_val(key_s);
-  size_t outlen = caml_string_length(out_s);
-  size_t inlen = caml_string_length(in_s);
-  size_t keylen = caml_string_length(key_s);
-  
-  int res = blake2b(out, outlen, in, inlen, key, keylen);
-  
-  return Val_int(res);
-}
-
-
-value blake2b_size_of_context_ml(value unit_v)
-{
-  return Val_int(sizeof(blake2b_state));
-}
-
-value blake2b_init_ml(value ctx_v, value outlen_v)
-{
-  blake2b_state* ctx = (blake2b_state*)String_val(ctx_v);
-  size_t outlen = Int_val(outlen_v);
-  blake2b_init( ctx, outlen );
-  
-  return ctx_v;
-}
-
-value blake2b_init_key_ml(value ctx_v, value outlen_v,value key_v)
-{
-  blake2b_state* ctx = (blake2b_state*)String_val(ctx_v);
-  size_t outlen = Int_val(outlen_v);
-  void* key = (void *)String_val(key_v);
-  size_t keylen = caml_string_length(key_v);
-  blake2b_init_key( ctx, outlen, key, keylen );
-  
-  return Val_unit;
-}
-
-value blake2b_update_ml(value ctx_v, value input_v)
-{
-  blake2b_state* ctx = (blake2b_state*)String_val(ctx_v);
-  void *input = (void *)String_val(input_v);
-  size_t inlen = caml_string_length(input_v);
-
-  blake2b_update( ctx, input, inlen );
-  return Val_unit;
-}
-
-value blake2b_final_ml(value ctx_v, value output_v)
-{
-  blake2b_state* ctx = (blake2b_state*)String_val(ctx_v);
-  void *output = (void *)String_val(output_v);
-  int outlen = caml_string_length(output_v);
-  blake2b_final( ctx, output,outlen );
-  return Val_unit;
-}
diff --git a/src/ez_hash/dune b/src/ez_hash/dune
deleted file mode 100644
index f657106..0000000
--- a/src/ez_hash/dune
+++ /dev/null
@@ -1,21 +0,0 @@
-; generated by drom from package skeleton 'library'
-
-(library
-  (name ez_hash)
-  (public_name ez_hash)
-  (wrapped false)
-  (libraries blake2 )
-  (foreign_stubs
-    (language c)
-    (names sha256 sha256-stubs sha3-ref sha3-stubs blake2b-stubs)
-    (flags (-O3)))
-  (c_library_flags )
-  
-  
-  )
-
-
-(documentation
-  (package ez_hash))
-
-
diff --git a/src/ez_hash/ezHash.ml b/src/ez_hash/ezHash.ml
deleted file mode 100644
index aa92c45..0000000
--- a/src/ez_hash/ezHash.ml
+++ /dev/null
@@ -1,219 +0,0 @@
-(**************************************************************************)
-(*                                                                        *)
-(*    Copyright 2017-2018 OCamlPro                                        *)
-(*                                                                        *)
-(*  All rights reserved. This file is distributed under the terms of the  *)
-(*  GNU Lesser General Public License version 2.1, with the special       *)
-(*  exception on linking described in the file LICENSE.                   *)
-(*                                                                        *)
-(**************************************************************************)
-
-open EzHex
-
-module RAW = struct
-
-  (* Code from BLAKE/BLAKE *)
-
-(*
-  external blake2b : (* out *)string -> (* in *)string -> (* key *)string ->
-    int = "blake2b_ml"
-
-  let blake2b ?(key = "") input =
-    let hash = String.make 64 '\000' in
-    let n = blake2b hash input key in
-    assert (n = 0);
-    hash
-*)
-
-  external blake2b_size_of_context : unit -> int = "blake2b_size_of_context_ml"
-
-  type blake2b_ctx
-  external blake2b_init : bytes -> int -> blake2b_ctx = "blake2b_init_ml"
-  external blake2b_init_key : bytes -> int -> string -> blake2b_ctx = "blake2b_init_key_ml"
-  external blake2b_update : blake2b_ctx -> string -> unit = "blake2b_update_ml"
-  external blake2b_final : blake2b_ctx -> bytes -> unit = "blake2b_final_ml"
-
-
-  let blake2b_ctx_size = blake2b_size_of_context ()
-
-  let blake2b_init ?key ?(size=64) () =
-    let ctx = Bytes.make blake2b_ctx_size '\000' in
-    let hash = Bytes.make size '\000' in
-    let ctx = match key with
-      | None -> blake2b_init ctx size
-      | Some key -> blake2b_init_key ctx size key in
-    ctx, hash
-
-  let blake2b_update (ctx,_) input = blake2b_update ctx input
-
-  let blake2b_final (ctx, hash) =
-    blake2b_final ctx hash;
-    Bytes.unsafe_to_string hash
-
-  let blake2b ?key input =
-    let ctx = blake2b_init ?key () in
-    blake2b_update ctx input;
-    blake2b_final ctx
-
-
-
-  (* Checks from Wikipedia :-) *)
-
-
-  let () =
-    let test_BLAKE2b_512 input =
-      String.uppercase_ascii (Hex.encode (blake2b input))
-    in
-    assert (test_BLAKE2b_512 "" =
-              "786A02F742015903C6C6FD852552D272912F4740E15847618A86E217F71F5419\
-               D25E1031AFEE585313896444934EB04B903A685B1448B755D56F701AFE9BE2CE");
-    assert (test_BLAKE2b_512 "The quick brown fox jumps over the lazy dog" =
-              "A8ADD4BDDDFD93E4877D2746E62817B116364A1FA7BC148D95090BC7333B3673\
-               F82401CF7AA2E4CB1ECD90296E3F14CB5413F8ED77BE73045B13914CDCD6A918");
-    ()
-
-  (* Code from PolarSSL *)
-
-(*
-  external sha256 : (* out *)string -> (* in *)string -> (* is224 *) bool -> unit = "sha256_ml"
-
-  let sha256 input =
-    let hash = String.make 32 '\000' in
-    sha256 hash input false;
-    hash
-*)
-
-  external sha256_size_of_context : unit -> int = "sha256_size_of_context_ml"
-
-  type sha256_ctx
-  external sha256_init : string -> sha256_ctx = "sha256_init_ml"
-  external sha256_update : sha256_ctx -> string -> unit = "sha256_update_ml"
-  external sha256_final : sha256_ctx -> string -> unit = "sha256_final_ml"
-
-  let sha256_ctx_size = sha256_size_of_context () (* 108 normally *)
-
-  let sha256_init () =
-    let ctx = String.make sha256_ctx_size '\000' in
-    let new_ctx = sha256_init ctx in
-    new_ctx
-
-  let sha256_final ctx =
-    let hash = String.make 32 '\000' in
-    sha256_final ctx hash;
-    hash
-
-  let sha256 input =
-    let ctx = sha256_init () in
-    sha256_update ctx input;
-    sha256_final ctx
-
-
-  let () =
-    let test_SHA256 input = Hex.encode (sha256 input)
-    in
-    assert (test_SHA256 "" =
-              "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855");
-
-    assert (test_SHA256 "The quick brown fox jumps over the lazy dog" =
-              "d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592");
-    ()
-
-
-
-  external sha3_size_of_context : unit -> int = "sha3_size_of_context_ml"
-
-  type sha3_ctx
-  type sha3_kind =
-    | KEC256
-    | KEC384
-    | KEC512
-
-  external sha3_init : string -> sha3_kind -> sha3_ctx = "sha3_init_ml"
-  external sha3_update : sha3_ctx -> string -> unit = "sha3_update_ml"
-  external sha3_final : sha3_ctx -> string -> unit = "sha3_final_ml"
-
-  let sha3_ctx_size = sha3_size_of_context () (* 108 normally *)
-
-  let sha3_init sha3_kind =
-    let ctx = String.make sha3_ctx_size '\000' in
-    let output = String.make (match sha3_kind with
-                              | KEC256 -> 32
-                              | KEC384 -> 48
-                              | KEC512 -> 64) '\000' in
-    let new_ctx = sha3_init ctx sha3_kind in
-    new_ctx, output
-
-  let sha3_update (ctx,_) s = sha3_update ctx s
-
-  let sha3_final (ctx, output) =
-    sha3_final ctx output;
-    output
-
-  let sha3 sha3_kind input =
-    let ctx = sha3_init sha3_kind in
-    sha3_update ctx input;
-    sha3_final ctx
-
-
-  let () =
-    let test_KEC input = Hex.encode (sha3 KEC256 input)
-    in
-    assert (test_KEC "" =
-              "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470");
-
-    assert (test_KEC "The quick brown fox jumps over the lazy dog" =
-              "4d741b6f1eb29cb2a9b9911c82f56fa8d73b04959d3d9d222895df6c0b28aa15");
-
-    ()
-end
-
-let digest = function
-  | `SHA256 -> RAW.sha256
-  | `SHA3_KEC -> RAW.sha3 RAW.KEC256
-  | `SHA3_KEC384 -> RAW.sha3 RAW.KEC384
-  | `SHA3_KEC512 -> RAW.sha3 RAW.KEC512
-
-module type HASH = sig
-  type t
-  val hash : string -> t (* typed *)
-  val hash_bytes : bytes -> t (* typed *)
-  val raw : t -> string
-  val size : int
-  val digest : string -> string (* untyped *)
-end
-
-module SHA256 : HASH = struct
-  type t = string
-  let hash = RAW.sha256
-  let hash_bytes b = hash (Bytes.unsafe_to_string b)
-  let digest = RAW.sha256
-  let raw t = t
-  let size = 32
-end
-
-module SHA3KEC : HASH = struct
-  type t = string
-  let hash = RAW.sha3 RAW.KEC256
-  let hash_bytes b = hash (Bytes.unsafe_to_string b)
-  let digest = RAW.sha3 RAW.KEC256
-  let raw t = t
-  let size = 32
-end
-
-module SHA3KEC512 : HASH = struct
-  type t = string
-  let hash = RAW.sha3 RAW.KEC512
-  let hash_bytes b = hash (Bytes.unsafe_to_string b)
-  let digest = RAW.sha3 RAW.KEC512
-  let raw t = t
-  let size = 64
-end
-
-module BLAKE2B : HASH = struct
-  type t = string
-  let hash = RAW.blake2b ?key:None
-  let hash_bytes b = hash (Bytes.unsafe_to_string b)
-  let digest = RAW.blake2b ?key:None
-  let raw t = t
-  let size = 64
-end
diff --git a/src/ez_hash/ezHash.mli b/src/ez_hash/ezHash.mli
deleted file mode 100644
index 3a257a7..0000000
--- a/src/ez_hash/ezHash.mli
+++ /dev/null
@@ -1,37 +0,0 @@
-(**************************************************************************)
-(*                                                                        *)
-(*    Copyright 2017-2018 OCamlPro                                        *)
-(*                                                                        *)
-(*  All rights reserved. This file is distributed under the terms of the  *)
-(*  GNU Lesser General Public License version 2.1, with the special       *)
-(*  exception on linking described in the file LICENSE.                   *)
-(*                                                                        *)
-(**************************************************************************)
-
-val digest :
-  [< `SHA256 | `SHA3_KEC | `SHA3_KEC384 | `SHA3_KEC512 ] -> string -> string
-
-module type HASH = sig
-  type t
-  val hash : string -> t
-  val hash_bytes : bytes -> t (* typed *)
-  val raw : t -> string
-  val size : int
-  val digest : string -> string (* untyped *)
-  end
-
-module SHA256 : HASH
-module SHA3KEC : HASH
-module SHA3KEC512 : HASH
-
-(*
-module BLAKE2B : HASH
-
-module RAW : sig
-  type blake2b_ctx
-  val blake2b_init : ?key:string -> ?size:int -> unit -> blake2b_ctx * bytes
-  val blake2b_update : blake2b_ctx * bytes -> string -> unit
-  val blake2b_final : blake2b_ctx * bytes -> string
-  val blake2b : ?key:string -> string -> string
-end
-*)
diff --git a/src/ez_hash/ezHex.ml b/src/ez_hash/ezHex.ml
deleted file mode 100644
index 4666533..0000000
--- a/src/ez_hash/ezHex.ml
+++ /dev/null
@@ -1,66 +0,0 @@
-(**************************************************************************)
-(*                                                                        *)
-(*    Copyright 2017-2018 OCamlPro                                        *)
-(*                                                                        *)
-(*  All rights reserved. This file is distributed under the terms of the  *)
-(*  GNU Lesser General Public License version 2.1, with the special       *)
-(*  exception on linking described in the file LICENSE.                   *)
-(*                                                                        *)
-(**************************************************************************)
-
-module Hex = struct
-
-  type t = string
-
-  let compare = String.compare
-  (* let equal = String.equal *)
-  let equal = (=)
-
-  let char_hex n =
-    Char.unsafe_chr (n + if n < 10 then Char.code '0' else (Char.code 'a' - 10))
-
-  let encode d =
-    let len = String.length d in
-    let result = Bytes.create (len*2) in
-    for i = 0 to len-1 do
-      let x = Char.code d.[i] in
-      Bytes.unsafe_set result (i*2) (char_hex (x lsr 4));
-      Bytes.unsafe_set result (i*2+1) (char_hex (x land 0x0f));
-    done;
-    Bytes.unsafe_to_string result
-
-  let char_hexU n =
-    Char.unsafe_chr (n + if n < 10 then Char.code '0' else (Char.code 'A' - 10))
-
-  let encodeU d =
-    let len = String.length d in
-    let result = Bytes.create (len*2) in
-    for i = 0 to len-1 do
-      let x = Char.code d.[i] in
-      Bytes.unsafe_set result (i*2) (char_hexU (x lsr 4));
-      Bytes.unsafe_set result (i*2+1) (char_hexU (x land 0x0f));
-    done;
-    Bytes.unsafe_to_string result
-
-  let decode s =
-    let len = String.length s in
-    if len mod 2 <> 0 then invalid_arg "Hex.decode";
-    let digit c =
-      match c with
-      | '0'..'9' -> Char.code c - Char.code '0'
-      | 'A'..'F' -> Char.code c - Char.code 'A' + 10
-      | 'a'..'f' -> Char.code c - Char.code 'a' + 10
-      | _ -> raise (Invalid_argument "Hex.decode")
-    in
-    let byte i = digit s.[i] lsl 4 + digit s.[i+1] in
-    let result = Bytes.create (len/2) in
-    for i = 0 to len/2 - 1 do
-      Bytes.set result i (Char.chr (byte (2 * i)));
-    done;
-    Bytes.unsafe_to_string result
-
-  let encode_bytes b = encode (Bytes.unsafe_to_string b)
-  let encodeU_bytes b = encodeU (Bytes.unsafe_to_string b)
-  let decode_bytes s = Bytes.unsafe_of_string (decode s)
-
-end
diff --git a/src/ez_hash/ezHex.mli b/src/ez_hash/ezHex.mli
deleted file mode 100644
index af45c2f..0000000
--- a/src/ez_hash/ezHex.mli
+++ /dev/null
@@ -1,39 +0,0 @@
-(**************************************************************************)
-(*                                                                        *)
-(*    Copyright 2017-2018 OCamlPro                                        *)
-(*                                                                        *)
-(*  All rights reserved. This file is distributed under the terms of the  *)
-(*  GNU Lesser General Public License version 2.1, with the special       *)
-(*  exception on linking described in the file LICENSE.                   *)
-(*                                                                        *)
-(**************************************************************************)
-
-module Hex : sig
-
-  type t = string
-
-  val compare : t -> t -> int
-  val equal : t -> t -> bool
-
-
-  (** [encode s] converts a string to a lowercase hexadecimal notation *)
-  val encode : string -> t
-
-  (** [encodeU s] converts a string to an uppercase hexadecimal notation *)
-  val encodeU : string -> t
-
-  (** [decode hex] converts a string in hexadecimal notation into its
-     corresponding decoded string. Can raise Invalid_argument. *)
-  val decode : t -> string
-
-  (** [encode s] converts a string to a lowercase hexadecimal notation *)
-  val encode_bytes : bytes -> t
-
-  (** [encodeU s] converts a string to an uppercase hexadecimal notation *)
-  val encodeU_bytes : bytes -> t
-
-  (** [decode hex] converts a string in hexadecimal notation into its
-     corresponding decoded string. Can raise Invalid_argument. *)
-  val decode_bytes : t -> bytes
-
-end
diff --git a/src/ez_hash/index.mld b/src/ez_hash/index.mld
deleted file mode 100644
index 9e2e11b..0000000
--- a/src/ez_hash/index.mld
+++ /dev/null
@@ -1,10 +0,0 @@
-{1 Library ez_hash}
-
-
-Ocaml-solidity provides a Solidity parser and typechecker
-
-
-
-This library exposes the following toplevel modules:
-{!modules:EzHash EzHex}
-
diff --git a/src/ez_hash/mbedtls_config.h b/src/ez_hash/mbedtls_config.h
deleted file mode 100644
index 5d5aff2..0000000
--- a/src/ez_hash/mbedtls_config.h
+++ /dev/null
@@ -1 +0,0 @@
-#define MBEDTLS_SHA256_C
diff --git a/src/ez_hash/package.toml b/src/ez_hash/package.toml
deleted file mode 100644
index ffed8f2..0000000
--- a/src/ez_hash/package.toml
+++ /dev/null
@@ -1,50 +0,0 @@
-
-# name of package
-name = "ez_hash"
-skeleton = "c_binding"
-
-# version if different from project version
-# version = "dev"
-
-# synopsis if different from project synopsis
-synopsis = "Hash functions: sha3, sha256, blake2b"
-
-# description if different from project description
-description = """\nHash functions: sha3, sha256, blake2b
-"""
-
-# kind is either "library", "program" or "virtual"
-kind = "library"
-
-# authors if different from project authors
-authors = ["Fabrice Le Fessant <fabrice.le_fessant@ocamlpro.com>"]
-
-# name of a file to generate with the current version
-# gen-version = "version.ml"
-
-# supported file generators are "ocamllex", "ocamlyacc" and "menhir" 
-# default is [ "ocamllex", "ocamlyacc" ] 
-# generators = [ "ocamllex", "menhir" ]
-
-# whether all modules should be packed/wrapped (default is true)
-pack-modules = false
-
-# module name used to pack modules (if pack-modules is true)
-# pack = "Mylib"
-
-# package library dependencies
-#   [dependencies]
-#   ez_file = ">=0.1 <1.3"
-#   base-unix = { libname = "unix", version = ">=base" } 
-[dependencies]
-blake2 = ""
-
-# package tools dependencies
-[tools]
-# ...
-
-# package fields (depends on package skeleton)
-[fields]
-c-flags = "(flags (-O3))"
-c-library-flags = ""
-c-names = "sha256 sha256-stubs sha3-ref sha3-stubs blake2b-stubs"
diff --git a/src/ez_hash/sha256-stubs.c b/src/ez_hash/sha256-stubs.c
deleted file mode 100644
index d497e14..0000000
--- a/src/ez_hash/sha256-stubs.c
+++ /dev/null
@@ -1,51 +0,0 @@
-
-#include <caml/mlvalues.h>
-#include <caml/alloc.h>
-
-#include "sha256.h"
-/*
-value sha256_ml(value out_v, value in_v, value is224_v)
-{
-  void* out = String_val(out_v);
-  void* in = String_val(in_v);
-  size_t outlen = caml_string_length(out_v);
-  size_t inlen = caml_string_length(in_v);
-  int is224 = Bool_val(is224_v);
-  
-  if( outlen != 32 ) return Val_int(-1);
-
-  mbedtls_sha256( in, inlen, out, is224);
-  
-  return Val_int(0);
-}
-*/
-value sha256_size_of_context_ml(value unit_v)
-{
-  return Val_int(sizeof(mbedtls_sha256_context));
-}
-
-value sha256_init_ml(value ctx_v)
-{
-  mbedtls_sha256_context* ctx = (mbedtls_sha256_context*)String_val(ctx_v);
-  mbedtls_sha256_init( ctx );
-  mbedtls_sha256_starts( ctx, 0 ); // 0 = is224 
-  return ctx_v;
-}
-
-value sha256_update_ml(value ctx_v, value input_v)
-{
-  mbedtls_sha256_context* ctx = (mbedtls_sha256_context*)String_val(ctx_v);
-  void *input = (void *)String_val(input_v);
-  size_t inlen = caml_string_length(input_v);
-
-  mbedtls_sha256_update( ctx, input, inlen );
-  return Val_unit;
-}
-
-value sha256_final_ml(value ctx_v, value output_v)
-{
-  mbedtls_sha256_context* ctx = (mbedtls_sha256_context*)String_val(ctx_v);
-  void *output = (void *)String_val(output_v);
-  mbedtls_sha256_finish( ctx, output );
-  return Val_unit;
-}
diff --git a/src/ez_hash/sha256.c b/src/ez_hash/sha256.c
deleted file mode 100644
index 6a073ac..0000000
--- a/src/ez_hash/sha256.c
+++ /dev/null
@@ -1,458 +0,0 @@
-/*
- *  FIPS-180-2 compliant SHA-256 implementation
- *
- *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
- *  SPDX-License-Identifier: Apache-2.0
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); you may
- *  not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- *  This file is part of mbed TLS (https://tls.mbed.org)
- */
-/*
- *  The SHA-256 Secure Hash Standard was published by NIST in 2002.
- *
- *  http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf
- */
-
-#if !defined(MBEDTLS_CONFIG_FILE)
-#include "mbedtls_config.h"
-#else
-#include MBEDTLS_CONFIG_FILE
-#endif
-
-#if defined(MBEDTLS_SHA256_C)
-
-#include "sha256.h"
-
-#include <string.h>
-
-#if defined(MBEDTLS_SELF_TEST)
-#if defined(MBEDTLS_PLATFORM_C)
-#include "mbedtls/platform.h"
-#else
-#include <stdio.h>
-#include <stdlib.h>
-#define mbedtls_printf printf
-#define mbedtls_calloc    calloc
-#define mbedtls_free       free
-#endif /* MBEDTLS_PLATFORM_C */
-#endif /* MBEDTLS_SELF_TEST */
-
-#if !defined(MBEDTLS_SHA256_ALT)
-
-/* Implementation that should never be optimized out by the compiler */
-static void mbedtls_zeroize( void *v, size_t n ) {
-    volatile unsigned char *p = v; while( n-- ) *p++ = 0;
-}
-
-/*
- * 32-bit integer manipulation macros (big endian)
- */
-#ifndef GET_UINT32_BE
-#define GET_UINT32_BE(n,b,i)                            \
-do {                                                    \
-    (n) = ( (uint32_t) (b)[(i)    ] << 24 )             \
-        | ( (uint32_t) (b)[(i) + 1] << 16 )             \
-        | ( (uint32_t) (b)[(i) + 2] <<  8 )             \
-        | ( (uint32_t) (b)[(i) + 3]       );            \
-} while( 0 )
-#endif
-
-#ifndef PUT_UINT32_BE
-#define PUT_UINT32_BE(n,b,i)                            \
-do {                                                    \
-    (b)[(i)    ] = (unsigned char) ( (n) >> 24 );       \
-    (b)[(i) + 1] = (unsigned char) ( (n) >> 16 );       \
-    (b)[(i) + 2] = (unsigned char) ( (n) >>  8 );       \
-    (b)[(i) + 3] = (unsigned char) ( (n)       );       \
-} while( 0 )
-#endif
-
-void mbedtls_sha256_init( mbedtls_sha256_context *ctx )
-{
-    memset( ctx, 0, sizeof( mbedtls_sha256_context ) );
-}
-
-void mbedtls_sha256_free( mbedtls_sha256_context *ctx )
-{
-    if( ctx == NULL )
-        return;
-
-    mbedtls_zeroize( ctx, sizeof( mbedtls_sha256_context ) );
-}
-
-void mbedtls_sha256_clone( mbedtls_sha256_context *dst,
-                           const mbedtls_sha256_context *src )
-{
-    *dst = *src;
-}
-
-/*
- * SHA-256 context setup
- */
-void mbedtls_sha256_starts( mbedtls_sha256_context *ctx, int is224 )
-{
-    ctx->total[0] = 0;
-    ctx->total[1] = 0;
-
-    if( is224 == 0 )
-    {
-        /* SHA-256 */
-        ctx->state[0] = 0x6A09E667;
-        ctx->state[1] = 0xBB67AE85;
-        ctx->state[2] = 0x3C6EF372;
-        ctx->state[3] = 0xA54FF53A;
-        ctx->state[4] = 0x510E527F;
-        ctx->state[5] = 0x9B05688C;
-        ctx->state[6] = 0x1F83D9AB;
-        ctx->state[7] = 0x5BE0CD19;
-    }
-    else
-    {
-        /* SHA-224 */
-        ctx->state[0] = 0xC1059ED8;
-        ctx->state[1] = 0x367CD507;
-        ctx->state[2] = 0x3070DD17;
-        ctx->state[3] = 0xF70E5939;
-        ctx->state[4] = 0xFFC00B31;
-        ctx->state[5] = 0x68581511;
-        ctx->state[6] = 0x64F98FA7;
-        ctx->state[7] = 0xBEFA4FA4;
-    }
-
-    ctx->is224 = is224;
-}
-
-#if !defined(MBEDTLS_SHA256_PROCESS_ALT)
-static const uint32_t K[] =
-{
-    0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
-    0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
-    0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
-    0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
-    0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
-    0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
-    0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
-    0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
-    0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
-    0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
-    0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
-    0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
-    0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
-    0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
-    0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
-    0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2,
-};
-
-#define  SHR(x,n) ((x & 0xFFFFFFFF) >> n)
-#define ROTR(x,n) (SHR(x,n) | (x << (32 - n)))
-
-#define S0(x) (ROTR(x, 7) ^ ROTR(x,18) ^  SHR(x, 3))
-#define S1(x) (ROTR(x,17) ^ ROTR(x,19) ^  SHR(x,10))
-
-#define S2(x) (ROTR(x, 2) ^ ROTR(x,13) ^ ROTR(x,22))
-#define S3(x) (ROTR(x, 6) ^ ROTR(x,11) ^ ROTR(x,25))
-
-#define F0(x,y,z) ((x & y) | (z & (x | y)))
-#define F1(x,y,z) (z ^ (x & (y ^ z)))
-
-#define R(t)                                    \
-(                                               \
-    W[t] = S1(W[t -  2]) + W[t -  7] +          \
-           S0(W[t - 15]) + W[t - 16]            \
-)
-
-#define P(a,b,c,d,e,f,g,h,x,K)                  \
-{                                               \
-    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
-    temp2 = S2(a) + F0(a,b,c);                  \
-    d += temp1; h = temp1 + temp2;              \
-}
-
-void mbedtls_sha256_process( mbedtls_sha256_context *ctx, const unsigned char data[64] )
-{
-    uint32_t temp1, temp2, W[64];
-    uint32_t A[8];
-    unsigned int i;
-
-    for( i = 0; i < 8; i++ )
-        A[i] = ctx->state[i];
-
-#if defined(MBEDTLS_SHA256_SMALLER)
-    for( i = 0; i < 64; i++ )
-    {
-        if( i < 16 )
-            GET_UINT32_BE( W[i], data, 4 * i );
-        else
-            R( i );
-
-        P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], W[i], K[i] );
-
-        temp1 = A[7]; A[7] = A[6]; A[6] = A[5]; A[5] = A[4]; A[4] = A[3];
-        A[3] = A[2]; A[2] = A[1]; A[1] = A[0]; A[0] = temp1;
-    }
-#else /* MBEDTLS_SHA256_SMALLER */
-    for( i = 0; i < 16; i++ )
-        GET_UINT32_BE( W[i], data, 4 * i );
-
-    for( i = 0; i < 16; i += 8 )
-    {
-        P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], W[i+0], K[i+0] );
-        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], W[i+1], K[i+1] );
-        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], W[i+2], K[i+2] );
-        P( A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], W[i+3], K[i+3] );
-        P( A[4], A[5], A[6], A[7], A[0], A[1], A[2], A[3], W[i+4], K[i+4] );
-        P( A[3], A[4], A[5], A[6], A[7], A[0], A[1], A[2], W[i+5], K[i+5] );
-        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], W[i+6], K[i+6] );
-        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], W[i+7], K[i+7] );
-    }
-
-    for( i = 16; i < 64; i += 8 )
-    {
-        P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], R(i+0), K[i+0] );
-        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], R(i+1), K[i+1] );
-        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], R(i+2), K[i+2] );
-        P( A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], R(i+3), K[i+3] );
-        P( A[4], A[5], A[6], A[7], A[0], A[1], A[2], A[3], R(i+4), K[i+4] );
-        P( A[3], A[4], A[5], A[6], A[7], A[0], A[1], A[2], R(i+5), K[i+5] );
-        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], R(i+6), K[i+6] );
-        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], R(i+7), K[i+7] );
-    }
-#endif /* MBEDTLS_SHA256_SMALLER */
-
-    for( i = 0; i < 8; i++ )
-        ctx->state[i] += A[i];
-}
-#endif /* !MBEDTLS_SHA256_PROCESS_ALT */
-
-/*
- * SHA-256 process buffer
- */
-void mbedtls_sha256_update( mbedtls_sha256_context *ctx, const unsigned char *input,
-                    size_t ilen )
-{
-    size_t fill;
-    uint32_t left;
-
-    if( ilen == 0 )
-        return;
-
-    left = ctx->total[0] & 0x3F;
-    fill = 64 - left;
-
-    ctx->total[0] += (uint32_t) ilen;
-    ctx->total[0] &= 0xFFFFFFFF;
-
-    if( ctx->total[0] < (uint32_t) ilen )
-        ctx->total[1]++;
-
-    if( left && ilen >= fill )
-    {
-        memcpy( (void *) (ctx->buffer + left), input, fill );
-        mbedtls_sha256_process( ctx, ctx->buffer );
-        input += fill;
-        ilen  -= fill;
-        left = 0;
-    }
-
-    while( ilen >= 64 )
-    {
-        mbedtls_sha256_process( ctx, input );
-        input += 64;
-        ilen  -= 64;
-    }
-
-    if( ilen > 0 )
-        memcpy( (void *) (ctx->buffer + left), input, ilen );
-}
-
-static const unsigned char sha256_padding[64] =
-{
- 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
-};
-
-/*
- * SHA-256 final digest
- */
-void mbedtls_sha256_finish( mbedtls_sha256_context *ctx, unsigned char output[32] )
-{
-    uint32_t last, padn;
-    uint32_t high, low;
-    unsigned char msglen[8];
-
-    high = ( ctx->total[0] >> 29 )
-         | ( ctx->total[1] <<  3 );
-    low  = ( ctx->total[0] <<  3 );
-
-    PUT_UINT32_BE( high, msglen, 0 );
-    PUT_UINT32_BE( low,  msglen, 4 );
-
-    last = ctx->total[0] & 0x3F;
-    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
-
-    mbedtls_sha256_update( ctx, sha256_padding, padn );
-    mbedtls_sha256_update( ctx, msglen, 8 );
-
-    PUT_UINT32_BE( ctx->state[0], output,  0 );
-    PUT_UINT32_BE( ctx->state[1], output,  4 );
-    PUT_UINT32_BE( ctx->state[2], output,  8 );
-    PUT_UINT32_BE( ctx->state[3], output, 12 );
-    PUT_UINT32_BE( ctx->state[4], output, 16 );
-    PUT_UINT32_BE( ctx->state[5], output, 20 );
-    PUT_UINT32_BE( ctx->state[6], output, 24 );
-
-    if( ctx->is224 == 0 )
-        PUT_UINT32_BE( ctx->state[7], output, 28 );
-}
-
-#endif /* !MBEDTLS_SHA256_ALT */
-
-/*
- * output = SHA-256( input buffer )
- */
-void mbedtls_sha256( const unsigned char *input, size_t ilen,
-             unsigned char output[32], int is224 )
-{
-    mbedtls_sha256_context ctx;
-
-    mbedtls_sha256_init( &ctx );
-    mbedtls_sha256_starts( &ctx, is224 );
-    mbedtls_sha256_update( &ctx, input, ilen );
-    mbedtls_sha256_finish( &ctx, output );
-    mbedtls_sha256_free( &ctx );
-}
-
-#if defined(MBEDTLS_SELF_TEST)
-/*
- * FIPS-180-2 test vectors
- */
-static const unsigned char sha256_test_buf[3][57] =
-{
-    { "abc" },
-    { "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq" },
-    { "" }
-};
-
-static const int sha256_test_buflen[3] =
-{
-    3, 56, 1000
-};
-
-static const unsigned char sha256_test_sum[6][32] =
-{
-    /*
-     * SHA-224 test vectors
-     */
-    { 0x23, 0x09, 0x7D, 0x22, 0x34, 0x05, 0xD8, 0x22,
-      0x86, 0x42, 0xA4, 0x77, 0xBD, 0xA2, 0x55, 0xB3,
-      0x2A, 0xAD, 0xBC, 0xE4, 0xBD, 0xA0, 0xB3, 0xF7,
-      0xE3, 0x6C, 0x9D, 0xA7 },
-    { 0x75, 0x38, 0x8B, 0x16, 0x51, 0x27, 0x76, 0xCC,
-      0x5D, 0xBA, 0x5D, 0xA1, 0xFD, 0x89, 0x01, 0x50,
-      0xB0, 0xC6, 0x45, 0x5C, 0xB4, 0xF5, 0x8B, 0x19,
-      0x52, 0x52, 0x25, 0x25 },
-    { 0x20, 0x79, 0x46, 0x55, 0x98, 0x0C, 0x91, 0xD8,
-      0xBB, 0xB4, 0xC1, 0xEA, 0x97, 0x61, 0x8A, 0x4B,
-      0xF0, 0x3F, 0x42, 0x58, 0x19, 0x48, 0xB2, 0xEE,
-      0x4E, 0xE7, 0xAD, 0x67 },
-
-    /*
-     * SHA-256 test vectors
-     */
-    { 0xBA, 0x78, 0x16, 0xBF, 0x8F, 0x01, 0xCF, 0xEA,
-      0x41, 0x41, 0x40, 0xDE, 0x5D, 0xAE, 0x22, 0x23,
-      0xB0, 0x03, 0x61, 0xA3, 0x96, 0x17, 0x7A, 0x9C,
-      0xB4, 0x10, 0xFF, 0x61, 0xF2, 0x00, 0x15, 0xAD },
-    { 0x24, 0x8D, 0x6A, 0x61, 0xD2, 0x06, 0x38, 0xB8,
-      0xE5, 0xC0, 0x26, 0x93, 0x0C, 0x3E, 0x60, 0x39,
-      0xA3, 0x3C, 0xE4, 0x59, 0x64, 0xFF, 0x21, 0x67,
-      0xF6, 0xEC, 0xED, 0xD4, 0x19, 0xDB, 0x06, 0xC1 },
-    { 0xCD, 0xC7, 0x6E, 0x5C, 0x99, 0x14, 0xFB, 0x92,
-      0x81, 0xA1, 0xC7, 0xE2, 0x84, 0xD7, 0x3E, 0x67,
-      0xF1, 0x80, 0x9A, 0x48, 0xA4, 0x97, 0x20, 0x0E,
-      0x04, 0x6D, 0x39, 0xCC, 0xC7, 0x11, 0x2C, 0xD0 }
-};
-
-/*
- * Checkup routine
- */
-int mbedtls_sha256_self_test( int verbose )
-{
-    int i, j, k, buflen, ret = 0;
-    unsigned char *buf;
-    unsigned char sha256sum[32];
-    mbedtls_sha256_context ctx;
-
-    buf = mbedtls_calloc( 1024, sizeof(unsigned char) );
-    if( NULL == buf )
-    {
-        if( verbose != 0 )
-            mbedtls_printf( "Buffer allocation failed\n" );
-
-        return( 1 );
-    }
-
-    mbedtls_sha256_init( &ctx );
-
-    for( i = 0; i < 6; i++ )
-    {
-        j = i % 3;
-        k = i < 3;
-
-        if( verbose != 0 )
-            mbedtls_printf( "  SHA-%d test #%d: ", 256 - k * 32, j + 1 );
-
-        mbedtls_sha256_starts( &ctx, k );
-
-        if( j == 2 )
-        {
-            memset( buf, 'a', buflen = 1000 );
-
-            for( j = 0; j < 1000; j++ )
-                mbedtls_sha256_update( &ctx, buf, buflen );
-        }
-        else
-            mbedtls_sha256_update( &ctx, sha256_test_buf[j],
-                                 sha256_test_buflen[j] );
-
-        mbedtls_sha256_finish( &ctx, sha256sum );
-
-        if( memcmp( sha256sum, sha256_test_sum[i], 32 - k * 4 ) != 0 )
-        {
-            if( verbose != 0 )
-                mbedtls_printf( "failed\n" );
-
-            ret = 1;
-            goto exit;
-        }
-
-        if( verbose != 0 )
-            mbedtls_printf( "passed\n" );
-    }
-
-    if( verbose != 0 )
-        mbedtls_printf( "\n" );
-
-exit:
-    mbedtls_sha256_free( &ctx );
-    mbedtls_free( buf );
-
-    return( ret );
-}
-
-#endif /* MBEDTLS_SELF_TEST */
-
-#endif /* MBEDTLS_SHA256_C */
diff --git a/src/ez_hash/sha256.h b/src/ez_hash/sha256.h
deleted file mode 100644
index 9750050..0000000
--- a/src/ez_hash/sha256.h
+++ /dev/null
@@ -1,141 +0,0 @@
-/**
- * \file sha256.h
- *
- * \brief SHA-224 and SHA-256 cryptographic hash function
- *
- *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
- *  SPDX-License-Identifier: Apache-2.0
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); you may
- *  not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- *  This file is part of mbed TLS (https://tls.mbed.org)
- */
-#ifndef MBEDTLS_SHA256_H
-#define MBEDTLS_SHA256_H
-
-#if !defined(MBEDTLS_CONFIG_FILE)
-#include "mbedtls_config.h"
-#else
-#include MBEDTLS_CONFIG_FILE
-#endif
-
-#include <stddef.h>
-#include <stdint.h>
-
-#if !defined(MBEDTLS_SHA256_ALT)
-// Regular implementation
-//
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \brief          SHA-256 context structure
- */
-typedef struct
-{
-    uint32_t total[2];          /*!< number of bytes processed  */
-    uint32_t state[8];          /*!< intermediate digest state  */
-    unsigned char buffer[64];   /*!< data block being processed */
-    int is224;                  /*!< 0 => SHA-256, else SHA-224 */
-}
-mbedtls_sha256_context;
-
-/**
- * \brief          Initialize SHA-256 context
- *
- * \param ctx      SHA-256 context to be initialized
- */
-void mbedtls_sha256_init( mbedtls_sha256_context *ctx );
-
-/**
- * \brief          Clear SHA-256 context
- *
- * \param ctx      SHA-256 context to be cleared
- */
-void mbedtls_sha256_free( mbedtls_sha256_context *ctx );
-
-/**
- * \brief          Clone (the state of) a SHA-256 context
- *
- * \param dst      The destination context
- * \param src      The context to be cloned
- */
-void mbedtls_sha256_clone( mbedtls_sha256_context *dst,
-                           const mbedtls_sha256_context *src );
-
-/**
- * \brief          SHA-256 context setup
- *
- * \param ctx      context to be initialized
- * \param is224    0 = use SHA256, 1 = use SHA224
- */
-void mbedtls_sha256_starts( mbedtls_sha256_context *ctx, int is224 );
-
-/**
- * \brief          SHA-256 process buffer
- *
- * \param ctx      SHA-256 context
- * \param input    buffer holding the  data
- * \param ilen     length of the input data
- */
-void mbedtls_sha256_update( mbedtls_sha256_context *ctx, const unsigned char *input,
-                    size_t ilen );
-
-/**
- * \brief          SHA-256 final digest
- *
- * \param ctx      SHA-256 context
- * \param output   SHA-224/256 checksum result
- */
-void mbedtls_sha256_finish( mbedtls_sha256_context *ctx, unsigned char output[32] );
-
-/* Internal use */
-void mbedtls_sha256_process( mbedtls_sha256_context *ctx, const unsigned char data[64] );
-
-#ifdef __cplusplus
-}
-#endif
-
-#else  /* MBEDTLS_SHA256_ALT */
-#include "sha256_alt.h"
-#endif /* MBEDTLS_SHA256_ALT */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \brief          Output = SHA-256( input buffer )
- *
- * \param input    buffer holding the  data
- * \param ilen     length of the input data
- * \param output   SHA-224/256 checksum result
- * \param is224    0 = use SHA256, 1 = use SHA224
- */
-void mbedtls_sha256( const unsigned char *input, size_t ilen,
-           unsigned char output[32], int is224 );
-
-/**
- * \brief          Checkup routine
- *
- * \return         0 if successful, or 1 if the test failed
- */
-int mbedtls_sha256_self_test( int verbose );
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* mbedtls_sha256.h */
diff --git a/src/ez_hash/sha3-ref.c b/src/ez_hash/sha3-ref.c
deleted file mode 100644
index a6604ff..0000000
--- a/src/ez_hash/sha3-ref.c
+++ /dev/null
@@ -1,288 +0,0 @@
-/* -------------------------------------------------------------------------
- * Works when compiled for either 32-bit or 64-bit targets, optimized for 
- * 64 bit.
- *
- * Canonical implementation of Init/Update/Finalize for SHA-3 byte input. 
- *
- * SHA3-256, SHA3-384, SHA-512 are implemented. SHA-224 can easily be added.
- *
- * Based on code from http://keccak.noekeon.org/ .
- *
- * I place the code that I wrote into public domain, free to use. 
- *
- * I would appreciate if you give credits to this work if you used it to 
- * write or test * your code.
- *
- * Aug 2015. Andrey Jivsov. crypto@brainhub.org
- * ---------------------------------------------------------------------- */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <string.h>
-
-#include "sha3-ref.h"
-
-#define SHA3_ASSERT( x )
-#if defined(_MSC_VER)
-#define SHA3_TRACE( format, ...)
-#define SHA3_TRACE_BUF( format, buf, l, ...)
-#else
-#define SHA3_TRACE(format, args...)
-#define SHA3_TRACE_BUF(format, buf, l, args...)
-#endif
-
-#define SHA3_USE_KECCAK
-/* 
- * Define SHA3_USE_KECCAK to run "pure" Keccak, as opposed to SHA3.
- * The tests that this macro enables use the input and output from [Keccak]
- * (see the reference below). The used test vectors aren't correct for SHA3, 
- * however, they are helpful to verify the implementation.
- * SHA3_USE_KECCAK only changes one line of code in Finalize.
- */
-
-#if defined(_MSC_VER)
-#define SHA3_CONST(x) x
-#else
-#define SHA3_CONST(x) x##L
-#endif
-
-/* The following state definition should normally be in a separate 
- * header file 
- */
-
-#ifndef SHA3_ROTL64
-#define SHA3_ROTL64(x, y) \
-	(((x) << (y)) | ((x) >> ((sizeof(uint64_t)*8) - (y))))
-#endif
-
-static const uint64_t keccakf_rndc[24] = {
-    SHA3_CONST(0x0000000000000001UL), SHA3_CONST(0x0000000000008082UL),
-    SHA3_CONST(0x800000000000808aUL), SHA3_CONST(0x8000000080008000UL),
-    SHA3_CONST(0x000000000000808bUL), SHA3_CONST(0x0000000080000001UL),
-    SHA3_CONST(0x8000000080008081UL), SHA3_CONST(0x8000000000008009UL),
-    SHA3_CONST(0x000000000000008aUL), SHA3_CONST(0x0000000000000088UL),
-    SHA3_CONST(0x0000000080008009UL), SHA3_CONST(0x000000008000000aUL),
-    SHA3_CONST(0x000000008000808bUL), SHA3_CONST(0x800000000000008bUL),
-    SHA3_CONST(0x8000000000008089UL), SHA3_CONST(0x8000000000008003UL),
-    SHA3_CONST(0x8000000000008002UL), SHA3_CONST(0x8000000000000080UL),
-    SHA3_CONST(0x000000000000800aUL), SHA3_CONST(0x800000008000000aUL),
-    SHA3_CONST(0x8000000080008081UL), SHA3_CONST(0x8000000000008080UL),
-    SHA3_CONST(0x0000000080000001UL), SHA3_CONST(0x8000000080008008UL)
-};
-
-static const unsigned keccakf_rotc[24] = {
-    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 2, 14, 27, 41, 56, 8, 25, 43, 62,
-    18, 39, 61, 20, 44
-};
-
-static const unsigned keccakf_piln[24] = {
-    10, 7, 11, 17, 18, 3, 5, 16, 8, 21, 24, 4, 15, 23, 19, 13, 12, 2, 20,
-    14, 22, 9, 6, 1
-};
-
-/* generally called after SHA3_KECCAK_SPONGE_WORDS-ctx->capacityWords words 
- * are XORed into the state s 
- */
-static void
-keccakf(uint64_t s[25])
-{
-    int i, j, round;
-    uint64_t t, bc[5];
-#define KECCAK_ROUNDS 24
-
-    for(round = 0; round < KECCAK_ROUNDS; round++) {
-
-        /* Theta */
-        for(i = 0; i < 5; i++)
-            bc[i] = s[i] ^ s[i + 5] ^ s[i + 10] ^ s[i + 15] ^ s[i + 20];
-
-        for(i = 0; i < 5; i++) {
-            t = bc[(i + 4) % 5] ^ SHA3_ROTL64(bc[(i + 1) % 5], 1);
-            for(j = 0; j < 25; j += 5)
-                s[j + i] ^= t;
-        }
-
-        /* Rho Pi */
-        t = s[1];
-        for(i = 0; i < 24; i++) {
-            j = keccakf_piln[i];
-            bc[0] = s[j];
-            s[j] = SHA3_ROTL64(t, keccakf_rotc[i]);
-            t = bc[0];
-        }
-
-        /* Chi */
-        for(j = 0; j < 25; j += 5) {
-            for(i = 0; i < 5; i++)
-                bc[i] = s[j + i];
-            for(i = 0; i < 5; i++)
-                s[j + i] ^= (~bc[(i + 1) % 5]) & bc[(i + 2) % 5];
-        }
-
-        /* Iota */
-        s[0] ^= keccakf_rndc[round];
-    }
-}
-
-/* *************************** Public Interface ************************ */
-
-/* For Init or Reset call these: */
-void sha3_Init256(sha3_context *ctx)
-{
-    memset(ctx, 0, sizeof(*ctx));
-    ctx->capacityWords = 2 * 256 / (8 * sizeof(uint64_t));
-}
-
-void sha3_Init384(sha3_context *ctx)
-{
-    memset(ctx, 0, sizeof(*ctx));
-    ctx->capacityWords = 2 * 384 / (8 * sizeof(uint64_t));
-}
-
-void sha3_Init512(sha3_context *ctx)
-{
-    memset(ctx, 0, sizeof(*ctx));
-    ctx->capacityWords = 2 * 512 / (8 * sizeof(uint64_t));
-}
-
-void sha3_Update(sha3_context *ctx, void const *bufIn, size_t len)
-{
-    /* 0...7 -- how much is needed to have a word */
-    unsigned old_tail = (8 - ctx->byteIndex) & 7;
-
-    size_t words;
-    unsigned tail;
-    size_t i;
-
-    const uint8_t *buf = bufIn;
-
-    SHA3_TRACE_BUF("called to update with:", buf, len);
-
-    SHA3_ASSERT(ctx->byteIndex < 8);
-    SHA3_ASSERT(ctx->wordIndex < sizeof(ctx->s) / sizeof(ctx->s[0]));
-
-    if(len < old_tail) {        /* have no complete word or haven't started 
-                                 * the word yet */
-        SHA3_TRACE("because %d<%d, store it and return", (unsigned)len,
-                (unsigned)old_tail);
-        /* endian-independent code follows: */
-        while (len--)
-            ctx->saved |= (uint64_t) (*(buf++)) << ((ctx->byteIndex++) * 8);
-        SHA3_ASSERT(ctx->byteIndex < 8);
-        return;
-    }
-
-    if(old_tail) {              /* will have one word to process */
-        SHA3_TRACE("completing one word with %d bytes", (unsigned)old_tail);
-        /* endian-independent code follows: */
-        len -= old_tail;
-        while (old_tail--)
-            ctx->saved |= (uint64_t) (*(buf++)) << ((ctx->byteIndex++) * 8);
-
-        /* now ready to add saved to the sponge */
-        ctx->s[ctx->wordIndex] ^= ctx->saved;
-        SHA3_ASSERT(ctx->byteIndex == 8);
-        ctx->byteIndex = 0;
-        ctx->saved = 0;
-        if(++ctx->wordIndex ==
-                (SHA3_KECCAK_SPONGE_WORDS - ctx->capacityWords)) {
-            keccakf(ctx->s);
-            ctx->wordIndex = 0;
-        }
-    }
-
-    /* now work in full words directly from input */
-
-    SHA3_ASSERT(ctx->byteIndex == 0);
-
-    words = len / sizeof(uint64_t);
-    tail = len - words * sizeof(uint64_t);
-
-    SHA3_TRACE("have %d full words to process", (unsigned)words);
-
-    for(i = 0; i < words; i++, buf += sizeof(uint64_t)) {
-        const uint64_t t = (uint64_t) (buf[0]) |
-                ((uint64_t) (buf[1]) << 8 * 1) |
-                ((uint64_t) (buf[2]) << 8 * 2) |
-                ((uint64_t) (buf[3]) << 8 * 3) |
-                ((uint64_t) (buf[4]) << 8 * 4) |
-                ((uint64_t) (buf[5]) << 8 * 5) |
-                ((uint64_t) (buf[6]) << 8 * 6) |
-                ((uint64_t) (buf[7]) << 8 * 7);
-#if defined(__x86_64__ ) || defined(__i386__)
-        SHA3_ASSERT(memcmp(&t, buf, 8) == 0);
-#endif
-        ctx->s[ctx->wordIndex] ^= t;
-        if(++ctx->wordIndex ==
-                (SHA3_KECCAK_SPONGE_WORDS - ctx->capacityWords)) {
-            keccakf(ctx->s);
-            ctx->wordIndex = 0;
-        }
-    }
-
-    SHA3_TRACE("have %d bytes left to process, save them", (unsigned)tail);
-
-    /* finally, save the partial word */
-    SHA3_ASSERT(ctx->byteIndex == 0 && tail < 8);
-    while (tail--) {
-        SHA3_TRACE("Store byte %02x '%c'", *buf, *buf);
-        ctx->saved |= (uint64_t) (*(buf++)) << ((ctx->byteIndex++) * 8);
-    }
-    SHA3_ASSERT(ctx->byteIndex < 8);
-    SHA3_TRACE("Have saved=0x%016" PRIx64 " at the end", ctx->saved);
-}
-
-/* This is simply the 'update' with the padding block.
- * The padding block is 0x01 || 0x00* || 0x80. First 0x01 and last 0x80 
- * bytes are always present, but they can be the same byte.
- */
-void const * sha3_Finalize(sha3_context *ctx)
-{
-    SHA3_TRACE("called with %d bytes in the buffer", ctx->byteIndex);
-
-    /* Append 2-bit suffix 01, per SHA-3 spec. Instead of 1 for padding we
-     * use 1<<2 below. The 0x02 below corresponds to the suffix 01.
-     * Overall, we feed 0, then 1, and finally 1 to start padding. Without
-     * M || 01, we would simply use 1 to start padding. */
-
-#ifndef SHA3_USE_KECCAK
-    /* SHA3 version */
-    ctx->s[ctx->wordIndex] ^=
-            (ctx->saved ^ ((uint64_t) ((uint64_t) (0x02 | (1 << 2)) <<
-                            ((ctx->byteIndex) * 8))));
-#else
-    /* For testing the "pure" Keccak version */
-    ctx->s[ctx->wordIndex] ^=
-            (ctx->saved ^ ((uint64_t) ((uint64_t) 1 << (ctx->byteIndex *
-                                    8))));
-#endif
-
-    ctx->s[SHA3_KECCAK_SPONGE_WORDS - ctx->capacityWords - 1] ^=
-            SHA3_CONST(0x8000000000000000UL);
-    keccakf(ctx->s);
-
-    /* Return first bytes of the ctx->s. This conversion is not needed for
-     * little-endian platforms e.g. wrap with #if !defined(__BYTE_ORDER__)
-     * || !defined(__ORDER_LITTLE_ENDIAN__) || \
-     * __BYTE_ORDER__!=__ORDER_LITTLE_ENDIAN__ ... the conversion below ...
-     * #endif */
-    {
-        unsigned i;
-        for(i = 0; i < SHA3_KECCAK_SPONGE_WORDS; i++) {
-            const unsigned t1 = (uint32_t) ctx->s[i];
-            const unsigned t2 = (uint32_t) ((ctx->s[i] >> 16) >> 16);
-            ctx->sb[i * 8 + 0] = (uint8_t) (t1);
-            ctx->sb[i * 8 + 1] = (uint8_t) (t1 >> 8);
-            ctx->sb[i * 8 + 2] = (uint8_t) (t1 >> 16);
-            ctx->sb[i * 8 + 3] = (uint8_t) (t1 >> 24);
-            ctx->sb[i * 8 + 4] = (uint8_t) (t2);
-            ctx->sb[i * 8 + 5] = (uint8_t) (t2 >> 8);
-            ctx->sb[i * 8 + 6] = (uint8_t) (t2 >> 16);
-            ctx->sb[i * 8 + 7] = (uint8_t) (t2 >> 24);
-        }
-    }
-
-    SHA3_TRACE_BUF("Hash: (first 32 bytes)", ctx->sb, 256 / 8);
-
-    return (ctx->sb);
-}
diff --git a/src/ez_hash/sha3-ref.h b/src/ez_hash/sha3-ref.h
deleted file mode 100644
index 66ad929..0000000
--- a/src/ez_hash/sha3-ref.h
+++ /dev/null
@@ -1,30 +0,0 @@
-
-#include <stdio.h>
-#include <stdint.h>
-#include <string.h>
-
-
-/* 'Words' here refers to uint64_t */
-#define SHA3_KECCAK_SPONGE_WORDS \
-	(((1600)/8/*bits to byte*/)/sizeof(uint64_t))
-typedef struct sha3_context_ {
-    uint64_t saved;             /* the portion of the input message that we
-                                 * didn't consume yet */
-    union {                     /* Keccak's state */
-        uint64_t s[SHA3_KECCAK_SPONGE_WORDS];
-        uint8_t sb[SHA3_KECCAK_SPONGE_WORDS * 8];
-    };
-    unsigned byteIndex;         /* 0..7--the next byte after the set one
-                                 * (starts from 0; 0--none are buffered) */
-    unsigned wordIndex;         /* 0..24--the next word to integrate input
-                                 * (starts from 0) */
-    unsigned capacityWords;     /* the double size of the hash output in
-                                 * words (e.g. 16 for Keccak 512) */
-} sha3_context;
-
-void sha3_Init256(sha3_context *priv);
-void sha3_Init384(sha3_context *priv);
-void sha3_Init512(sha3_context *priv);
-
-void sha3_Update(sha3_context *ctx, void const *bufIn, size_t len);
-void const * sha3_Finalize(sha3_context *ctx);
diff --git a/src/ez_hash/sha3-stubs.c b/src/ez_hash/sha3-stubs.c
deleted file mode 100644
index 129e7d1..0000000
--- a/src/ez_hash/sha3-stubs.c
+++ /dev/null
@@ -1,49 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/*    Copyright (c) 2017       .                                          */
-/*    Fabrice Le Fessant, INRIA & OCamlPro SAS <fabrice@lefessant.net>    */
-/*                                                                        */
-/*    All rights reserved. No warranty, explicit or implicit, provided.   */
-/*                                                                        */
-/**************************************************************************/
-
-#include <caml/mlvalues.h>
-#include <caml/alloc.h>
-
-#include "sha3-ref.h"
-
-value sha3_size_of_context_ml(value unit_v)
-{
-  return Val_int(sizeof(sha3_context));
-}
-
-value sha3_init_ml(value ctx_v, value kind_v)
-{
-  sha3_context* ctx = (sha3_context*)String_val(ctx_v);
-  int kind = Int_val(kind_v);
-  if(kind == 0) sha3_Init256( ctx );
-  else if(kind == 1) sha3_Init384( ctx );
-  else sha3_Init512( ctx );
-  return ctx_v;
-}
-
-value sha3_update_ml(value ctx_v, value input_v)
-{
-  sha3_context* ctx = (sha3_context*)String_val(ctx_v);
-  void *input = (void *)String_val(input_v);
-  size_t inlen = caml_string_length(input_v);
-
-  sha3_Update( ctx, input, inlen );
-  return Val_unit;
-}
-
-value sha3_final_ml(value ctx_v, value output_v)
-{
-  sha3_context* ctx = (sha3_context*)String_val(ctx_v);
-  void *output = (void *)String_val(output_v);
-  void const * res = sha3_Finalize( ctx );
-  
-  memcpy(output, res, caml_string_length(output_v));
-
-  return Val_unit;
-}
diff --git a/src/ez_hash/sha3-tests.c b/src/ez_hash/sha3-tests.c
deleted file mode 100644
index e33baa9..0000000
--- a/src/ez_hash/sha3-tests.c
+++ /dev/null
@@ -1,325 +0,0 @@
-
-/* *************************** Self Tests ************************ */
-
-/* 
- * There are two set of mutually exclusive tests, based on SHA3_USE_KECCAK,
- * which is undefined in the production version.
- *
- * Known answer tests are from NIST SHA3 test vectors at
- * http://csrc.nist.gov/groups/ST/toolkit/examples.html
- *
- * SHA3-256:
- *   http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/SHA3-256_Msg0.pdf
- *   http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/SHA3-256_1600.pdf
- * SHA3-384: 
- *   http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/SHA3-384_1600.pdf 
- * SHA3-512: 
- *   http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/SHA3-512_1600.pdf 
- *
- * These are refered to as [FIPS 202] tests.
- *
- * -----
- *
- * A few Keccak algorithm tests (when M and not M||01 is hashed) are
- * added here. These are from http://keccak.noekeon.org/KeccakKAT-3.zip,
- * ShortMsgKAT_256.txt for sizes even to 8. There is also one test for 
- * ExtremelyLongMsgKAT_256.txt.
- *
- * These will work with this code when SHA3_USE_KECCAK converts Finalize
- * to use "pure" Keccak algorithm.
- *
- *
- * These are referred to as [Keccak] test.
- *
- * -----
- *
- * In one case the input from [Keccak] test was used to test SHA3
- * implementation. In this case the calculated hash was compared with
- * the output of the sha3sum on Fedora Core 20 (which is Perl's based).
- *
- */
-
-int
-main()
-{
-    uint8_t buf[200];
-    sha3_context c;
-    const uint8_t *hash;
-    unsigned i;
-    const uint8_t c1 = 0xa3;
-
-#ifndef SHA3_USE_KECCAK
-    /* [FIPS 202] KAT follow */
-    const static uint8_t sha3_256_empty[256 / 8] = {
-        0xa7, 0xff, 0xc6, 0xf8, 0xbf, 0x1e, 0xd7, 0x66,
-	0x51, 0xc1, 0x47, 0x56, 0xa0, 0x61, 0xd6, 0x62,
-	0xf5, 0x80, 0xff, 0x4d, 0xe4, 0x3b, 0x49, 0xfa, 
-	0x82, 0xd8, 0x0a, 0x4b, 0x80, 0xf8, 0x43, 0x4a
-    };
-    const static uint8_t sha3_256_0xa3_200_times[256 / 8] = {
-        0x79, 0xf3, 0x8a, 0xde, 0xc5, 0xc2, 0x03, 0x07,
-        0xa9, 0x8e, 0xf7, 0x6e, 0x83, 0x24, 0xaf, 0xbf,
-        0xd4, 0x6c, 0xfd, 0x81, 0xb2, 0x2e, 0x39, 0x73,
-        0xc6, 0x5f, 0xa1, 0xbd, 0x9d, 0xe3, 0x17, 0x87
-    };
-    const static uint8_t sha3_384_0xa3_200_times[384 / 8] = {
-        0x18, 0x81, 0xde, 0x2c, 0xa7, 0xe4, 0x1e, 0xf9,
-        0x5d, 0xc4, 0x73, 0x2b, 0x8f, 0x5f, 0x00, 0x2b,
-        0x18, 0x9c, 0xc1, 0xe4, 0x2b, 0x74, 0x16, 0x8e,
-        0xd1, 0x73, 0x26, 0x49, 0xce, 0x1d, 0xbc, 0xdd,
-        0x76, 0x19, 0x7a, 0x31, 0xfd, 0x55, 0xee, 0x98,
-        0x9f, 0x2d, 0x70, 0x50, 0xdd, 0x47, 0x3e, 0x8f
-    };
-    const static uint8_t sha3_512_0xa3_200_times[512 / 8] = {
-        0xe7, 0x6d, 0xfa, 0xd2, 0x20, 0x84, 0xa8, 0xb1,
-        0x46, 0x7f, 0xcf, 0x2f, 0xfa, 0x58, 0x36, 0x1b,
-        0xec, 0x76, 0x28, 0xed, 0xf5, 0xf3, 0xfd, 0xc0,
-        0xe4, 0x80, 0x5d, 0xc4, 0x8c, 0xae, 0xec, 0xa8,
-        0x1b, 0x7c, 0x13, 0xc3, 0x0a, 0xdf, 0x52, 0xa3,
-        0x65, 0x95, 0x84, 0x73, 0x9a, 0x2d, 0xf4, 0x6b,
-        0xe5, 0x89, 0xc5, 0x1c, 0xa1, 0xa4, 0xa8, 0x41,
-        0x6d, 0xf6, 0x54, 0x5a, 0x1c, 0xe8, 0xba, 0x00
-    };
-#endif
-
-    memset(buf, c1, sizeof(buf));
-
-#ifdef SHA3_USE_KECCAK          /* run tests against "pure" Keccak
-                                 * algorithm; from [Keccak] */
-
-    sha3_Init256(&c);
-    sha3_Update(&c, "\xcc", 1);
-    hash = sha3_Finalize(&c);
-    if(memcmp(hash, "\xee\xad\x6d\xbf\xc7\x34\x0a\x56"
-                    "\xca\xed\xc0\x44\x69\x6a\x16\x88"
-                    "\x70\x54\x9a\x6a\x7f\x6f\x56\x96"
-                    "\x1e\x84\xa5\x4b\xd9\x97\x0b\x8a", 256 / 8) != 0) {
-        printf("SHA3-256(cc) "
-                "doesn't match known answer (single buffer)\n");
-        return 11;
-    }
-
-    sha3_Init256(&c);
-    sha3_Update(&c, "\x41\xfb", 2);
-    hash = sha3_Finalize(&c);
-    if(memcmp(hash, "\xa8\xea\xce\xda\x4d\x47\xb3\x28"
-                    "\x1a\x79\x5a\xd9\xe1\xea\x21\x22"
-                    "\xb4\x07\xba\xf9\xaa\xbc\xb9\xe1"
-                    "\x8b\x57\x17\xb7\x87\x35\x37\xd2", 256 / 8) != 0) {
-        printf("SHA3-256(41fb) "
-                "doesn't match known answer (single buffer)\n");
-        return 12;
-    }
-
-    sha3_Init256(&c);
-    sha3_Update(&c,
-            "\x52\xa6\x08\xab\x21\xcc\xdd\x8a"
-            "\x44\x57\xa5\x7e\xde\x78\x21\x76", 128 / 8);
-    hash = sha3_Finalize(&c);
-    if(memcmp(hash, "\x0e\x32\xde\xfa\x20\x71\xf0\xb5"
-                    "\xac\x0e\x6a\x10\x8b\x84\x2e\xd0"
-                    "\xf1\xd3\x24\x97\x12\xf5\x8e\xe0"
-                    "\xdd\xf9\x56\xfe\x33\x2a\x5f\x95", 256 / 8) != 0) {
-        printf("SHA3-256(52a6...76) "
-                "doesn't match known answer (single buffer)\n");
-        return 13;
-    }
-
-    sha3_Init256(&c);
-    sha3_Update(&c,
-            "\x43\x3c\x53\x03\x13\x16\x24\xc0"
-            "\x02\x1d\x86\x8a\x30\x82\x54\x75"
-            "\xe8\xd0\xbd\x30\x52\xa0\x22\x18"
-            "\x03\x98\xf4\xca\x44\x23\xb9\x82"
-            "\x14\xb6\xbe\xaa\xc2\x1c\x88\x07"
-            "\xa2\xc3\x3f\x8c\x93\xbd\x42\xb0"
-            "\x92\xcc\x1b\x06\xce\xdf\x32\x24"
-            "\xd5\xed\x1e\xc2\x97\x84\x44\x4f"
-            "\x22\xe0\x8a\x55\xaa\x58\x54\x2b"
-            "\x52\x4b\x02\xcd\x3d\x5d\x5f\x69"
-            "\x07\xaf\xe7\x1c\x5d\x74\x62\x22"
-            "\x4a\x3f\x9d\x9e\x53\xe7\xe0\x84" "\x6d\xcb\xb4\xce", 800 / 8);
-    hash = sha3_Finalize(&c);
-    if(memcmp(hash, "\xce\x87\xa5\x17\x3b\xff\xd9\x23"
-                    "\x99\x22\x16\x58\xf8\x01\xd4\x5c"
-                    "\x29\x4d\x90\x06\xee\x9f\x3f\x9d"
-                    "\x41\x9c\x8d\x42\x77\x48\xdc\x41", 256 / 8) != 0) {
-        printf("SHA3-256(433C...CE) "
-                "doesn't match known answer (single buffer)\n");
-        return 14;
-    }
-
-    /* SHA3-256 byte-by-byte: 16777216 steps. ExtremelyLongMsgKAT_256
-     * [Keccak] */
-    i = 16777216;
-    sha3_Init256(&c);
-    while (i--) {
-        sha3_Update(&c,
-                "abcdefghbcdefghicdefghijdefghijk"
-                "efghijklfghijklmghijklmnhijklmno", 64);
-    }
-    hash = sha3_Finalize(&c);
-    if(memcmp(hash, "\x5f\x31\x3c\x39\x96\x3d\xcf\x79"
-                    "\x2b\x54\x70\xd4\xad\xe9\xf3\xa3"
-                    "\x56\xa3\xe4\x02\x17\x48\x69\x0a"
-                    "\x95\x83\x72\xe2\xb0\x6f\x82\xa4", 256 / 8) != 0) {
-        printf("SHA3-256( abcdefgh...[16777216 times] ) "
-                "doesn't match known answer\n");
-        return 15;
-    }
-#else                           /* SHA3 testing begins */
-
-    /* SHA-256 on an empty buffer */
-    sha3_Init256(&c);
-    hash = sha3_Finalize(&c);
-    if(memcmp(sha3_256_empty, hash, sizeof(sha3_256_empty)) != 0) {
-        printf("SHA3-256() doesn't match known answer\n");
-        return 1;
-    }
-
-    /* SHA3-256 as a single buffer. [FIPS 202] */
-    sha3_Init256(&c);
-    sha3_Update(&c, buf, sizeof(buf));
-    hash = sha3_Finalize(&c);
-    if(memcmp(sha3_256_0xa3_200_times, hash,
-                    sizeof(sha3_256_0xa3_200_times)) != 0) {
-        printf("SHA3-256( 0xa3 ... [200 times] ) "
-                "doesn't match known answer (1 buffer)\n");
-        return 1;
-    }
-
-    /* SHA3-256 in two steps. [FIPS 202] */
-    sha3_Init256(&c);
-    sha3_Update(&c, buf, sizeof(buf) / 2);
-    sha3_Update(&c, buf + sizeof(buf) / 2, sizeof(buf) / 2);
-    hash = sha3_Finalize(&c);
-    if(memcmp(sha3_256_0xa3_200_times, hash,
-                    sizeof(sha3_256_0xa3_200_times)) != 0) {
-        printf("SHA3-256( 0xa3 ... [200 times] ) "
-                "doesn't match known answer (2 steps)\n");
-        return 2;
-    }
-
-    /* SHA3-256 byte-by-byte: 200 steps. [FIPS 202] */
-    i = 200;
-    sha3_Init256(&c);
-    while (i--) {
-        sha3_Update(&c, &c1, 1);
-    }
-    hash = sha3_Finalize(&c);
-    if(memcmp(sha3_256_0xa3_200_times, hash,
-                    sizeof(sha3_256_0xa3_200_times)) != 0) {
-        printf("SHA3-256( 0xa3 ... [200 times] ) "
-                "doesn't match known answer (200 steps)\n");
-        return 3;
-    }
-
-    /* SHA3-256 byte-by-byte: 135 bytes. Input from [Keccak]. Output
-     * matched with sha3sum. */
-    sha3_Init256(&c);
-    sha3_Update(&c,
-            "\xb7\x71\xd5\xce\xf5\xd1\xa4\x1a"
-            "\x93\xd1\x56\x43\xd7\x18\x1d\x2a"
-            "\x2e\xf0\xa8\xe8\x4d\x91\x81\x2f"
-            "\x20\xed\x21\xf1\x47\xbe\xf7\x32"
-            "\xbf\x3a\x60\xef\x40\x67\xc3\x73"
-            "\x4b\x85\xbc\x8c\xd4\x71\x78\x0f"
-            "\x10\xdc\x9e\x82\x91\xb5\x83\x39"
-            "\xa6\x77\xb9\x60\x21\x8f\x71\xe7"
-            "\x93\xf2\x79\x7a\xea\x34\x94\x06"
-            "\x51\x28\x29\x06\x5d\x37\xbb\x55"
-            "\xea\x79\x6f\xa4\xf5\x6f\xd8\x89"
-            "\x6b\x49\xb2\xcd\x19\xb4\x32\x15"
-            "\xad\x96\x7c\x71\x2b\x24\xe5\x03"
-            "\x2d\x06\x52\x32\xe0\x2c\x12\x74"
-            "\x09\xd2\xed\x41\x46\xb9\xd7\x5d"
-            "\x76\x3d\x52\xdb\x98\xd9\x49\xd3"
-            "\xb0\xfe\xd6\xa8\x05\x2f\xbb", 1080 / 8);
-    hash = sha3_Finalize(&c);
-    if(memcmp(hash, "\xa1\x9e\xee\x92\xbb\x20\x97\xb6"
-                    "\x4e\x82\x3d\x59\x77\x98\xaa\x18"
-                    "\xbe\x9b\x7c\x73\x6b\x80\x59\xab"
-                    "\xfd\x67\x79\xac\x35\xac\x81\xb5", 256 / 8) != 0) {
-        printf("SHA3-256( b771 ... ) doesn't match the known answer\n");
-        return 4;
-    }
-
-    /* SHA3-384 as a single buffer. [FIPS 202] */
-    sha3_Init384(&c);
-    sha3_Update(&c, buf, sizeof(buf));
-    hash = sha3_Finalize(&c);
-    if(memcmp(sha3_384_0xa3_200_times, hash,
-                    sizeof(sha3_384_0xa3_200_times)) != 0) {
-        printf("SHA3-384( 0xa3 ... [200 times] ) "
-                "doesn't match known answer (1 buffer)\n");
-        return 5;
-    }
-
-    /* SHA3-384 in two steps. [FIPS 202] */
-    sha3_Init384(&c);
-    sha3_Update(&c, buf, sizeof(buf) / 2);
-    sha3_Update(&c, buf + sizeof(buf) / 2, sizeof(buf) / 2);
-    hash = sha3_Finalize(&c);
-    if(memcmp(sha3_384_0xa3_200_times, hash,
-                    sizeof(sha3_384_0xa3_200_times)) != 0) {
-        printf("SHA3-384( 0xa3 ... [200 times] ) "
-                "doesn't match known answer (2 steps)\n");
-        return 6;
-    }
-
-    /* SHA3-384 byte-by-byte: 200 steps. [FIPS 202] */
-    i = 200;
-    sha3_Init384(&c);
-    while (i--) {
-        sha3_Update(&c, &c1, 1);
-    }
-    hash = sha3_Finalize(&c);
-    if(memcmp(sha3_384_0xa3_200_times, hash,
-                    sizeof(sha3_384_0xa3_200_times)) != 0) {
-        printf("SHA3-384( 0xa3 ... [200 times] ) "
-                "doesn't match known answer (200 steps)\n");
-        return 7;
-    }
-
-    /* SHA3-512 as a single buffer. [FIPS 202] */
-    sha3_Init512(&c);
-    sha3_Update(&c, buf, sizeof(buf));
-    hash = sha3_Finalize(&c);
-    if(memcmp(sha3_512_0xa3_200_times, hash,
-                    sizeof(sha3_512_0xa3_200_times)) != 0) {
-        printf("SHA3-512( 0xa3 ... [200 times] ) "
-                "doesn't match known answer (1 buffer)\n");
-        return 8;
-    }
-
-    /* SHA3-512 in two steps. [FIPS 202] */
-    sha3_Init512(&c);
-    sha3_Update(&c, buf, sizeof(buf) / 2);
-    sha3_Update(&c, buf + sizeof(buf) / 2, sizeof(buf) / 2);
-    hash = sha3_Finalize(&c);
-    if(memcmp(sha3_512_0xa3_200_times, hash,
-                    sizeof(sha3_512_0xa3_200_times)) != 0) {
-        printf("SHA3-512( 0xa3 ... [200 times] ) "
-                "doesn't match known answer (2 steps)\n");
-        return 9;
-    }
-
-    /* SHA3-512 byte-by-byte: 200 steps. [FIPS 202] */
-    i = 200;
-    sha3_Init512(&c);
-    while (i--) {
-        sha3_Update(&c, &c1, 1);
-    }
-    hash = sha3_Finalize(&c);
-    if(memcmp(sha3_512_0xa3_200_times, hash,
-                    sizeof(sha3_512_0xa3_200_times)) != 0) {
-        printf("SHA3-512( 0xa3 ... [200 times] ) "
-                "doesn't match known answer (200 steps)\n");
-        return 10;
-    }
-#endif
-
-    printf("SHA3-256, SHA3-384, SHA3-512 tests passed OK\n");
-
-    return 0;
-}
